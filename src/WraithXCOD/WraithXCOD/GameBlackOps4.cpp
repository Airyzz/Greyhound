#include "stdafx.h"

// The class we are implementing
#include "GameBlackOps4.h"

// We need the CoDAssets class
#include "CoDAssets.h"
#include "CoDRawImageTranslator.h"
#include "CoDXPoolParser.h"

// We need the following WraithX classes
#include "Strings.h"
#include "FileSystems.h"
#include "MemoryReader.h"
#include "SettingsManager.h"
#include "HalfFloats.h"

// -- Initialize Asset Name Cache

WraithNameIndex GameBlackOps4::AssetNameCache = WraithNameIndex();

// -- Initialize Decryption Table

uint32_t* DecryptionTable = new uint32_t[0x1000]
{
	0x02484D3D, 0x18B9BCBB, 0x09A44DA8, 0x134EAD39, 0x1F45F4A1, 0x002300BA,
	0x07996D23, 0x17094334, 0x17CE7425, 0x1B769619, 0x18C035F9, 0x123CCF30,
	0x0AEE3D96, 0x0E7D2312, 0x0B1615F1, 0x03CACFC9, 0x1E901EB1, 0x02DC9AE5,
	0x0C5A914E, 0x13EFC3CC, 0x14AC2FA6, 0x0960B96D, 0x0679EC15, 0x167C6863,
	0x03047B63, 0x0E8102E0, 0x0459E66F, 0x128CC800, 0x05D7464B, 0x04454C73,
	0x1C7CAA44, 0x1A5D2EB7, 0x0EAD8BED, 0x1BE8A403, 0x0B5A64EC, 0x1D920C65,
	0x0C21DD17, 0x0E2C0D12, 0x17337FA0, 0x0E121ABC, 0x0F6CE369, 0x1309FF08,
	0x004F55F5, 0x116677ED, 0x0E84B864, 0x1528A8D9, 0x100F93E6, 0x1C1DE01A,
	0x0F839245, 0x04D9FAC0, 0x066C3334, 0x1A0F3F35, 0x0EDF0680, 0x0EC191D1,
	0x07DCB393, 0x1DE28CDB, 0x136D7135, 0x1DD682B5, 0x1F19F059, 0x01087AF2,
	0x143D0E91, 0x1FE9025B, 0x08A4A457, 0x1D8E2E84, 0x0057D169, 0x0A769F43,
	0x10C7BB2A, 0x1BCF687D, 0x1AD9EF16, 0x03953EBB, 0x102D8B36, 0x043A0D7C,
	0x006DC1F5, 0x11D09452, 0x1B7D93A3, 0x15F81A72, 0x04117C2A, 0x0A53E48A,
	0x09E8E9A6, 0x1A1AD9FB, 0x1040ECB1, 0x11906F6A, 0x15E50F36, 0x11161217,
	0x13995212, 0x0B3DD2D0, 0x17105755, 0x19E4BC99, 0x0E74860A, 0x0A60277E,
	0x020DEA12, 0x0D29B170, 0x0B5A725D, 0x168E4968, 0x03B120DA, 0x1CEDEE72,
	0x0EE6C5A8, 0x09B8C4F4, 0x02D49D42, 0x10EE0CE4, 0x1668F00D, 0x1C720A01,
	0x1CCB096A, 0x112C3665, 0x15AAF53A, 0x0C1B6B55, 0x126E916C, 0x1E1238F5,
	0x192A7FC6, 0x13001D3A, 0x08B6EDFD, 0x0F2C6B15, 0x046B91A1, 0x0AC01979,
	0x07AD7E6E, 0x05073CF2, 0x1AADB733, 0x02A6665F, 0x1C3500CB, 0x069DE515,
	0x15DDC35B, 0x0E7F5F78, 0x104F6334, 0x02655204, 0x1A6807D5, 0x16348218,
	0x07FE3E87, 0x14010DB6, 0x05DFB042, 0x17D04C70, 0x1252A5B7, 0x04ACF1F0,
	0x0BB4AFFA, 0x0281CB00, 0x1AFAB1C5, 0x0A8513EF, 0x004584F0, 0x1E8DF2B8,
	0x11AB9586, 0x16C5A7AD, 0x12A6E7CC, 0x0C10A6AE, 0x1738D918, 0x0334A390,
	0x1AA08024, 0x026C7055, 0x1AF4C848, 0x099DA24A, 0x192F1036, 0x061A5091,
	0x14F7F965, 0x1861E29D, 0x1633AC04, 0x0E3FB0E3, 0x07F9F2AE, 0x0C5FAC9B,
	0x199E819C, 0x128F40F9, 0x12127392, 0x190B8499, 0x18E5DCFE, 0x073AFE7F,
	0x1F95F151, 0x101D0A47, 0x1EA2596F, 0x07C461B1, 0x0EF68C65, 0x1823B23E,
	0x1194F600, 0x0F38EE1C, 0x187C4ED6, 0x1B5F862A, 0x0DA033F9, 0x0F44377F,
	0x1882EF6A, 0x1AB13C77, 0x0A58664B, 0x00FF7125, 0x0A2A9273, 0x1C5468BB,
	0x0781D24A, 0x1F6E81D3, 0x18438CB0, 0x18F038EB, 0x005D5ECA, 0x0CCE8E8E,
	0x121E1E90, 0x0C5EEF38, 0x1E5FF8B0, 0x15F83468, 0x09B21F03, 0x01857915,
	0x06AF98E3, 0x1B0677DD, 0x05BE3F31, 0x11DEE7AE, 0x0D9D02B1, 0x1A48F6BD,
	0x0E110B7A, 0x081F648E, 0x0D861002, 0x0018EB7C, 0x0AD18353, 0x1E2AED3A,
	0x1FFD708A, 0x164D14E3, 0x15BBAE3F, 0x180F1326, 0x18910C66, 0x0D1322F5,
	0x0D3C9492, 0x12F6F107, 0x1988F07C, 0x1653F200, 0x0C7F2E13, 0x111B7C5C,
	0x0EC91E2A, 0x0B47E853, 0x141F6E80, 0x0280C151, 0x18CC058E, 0x107909FE,
	0x0D467F13, 0x016EE43C, 0x07618133, 0x01514FBA, 0x084173D0, 0x16C3D66D,
	0x01F72A49, 0x0233841D, 0x17C2C295, 0x180015D6, 0x0FFB0B7E, 0x15161C4F,
	0x0C2A16F8, 0x112D6630, 0x1923F774, 0x0F5155B5, 0x002228AC, 0x158F816D,
	0x1470B9AE, 0x1921F67D, 0x1CDD9373, 0x036A3D66, 0x1EF77D93, 0x1C0493E7,
	0x0614C82F, 0x09581319, 0x0EF39BC5, 0x0C148267, 0x0A1DEC3D, 0x04407DB5,
	0x15DFEBBE, 0x0CDCE988, 0x012CDD7D, 0x119BD7A6, 0x11AE31DB, 0x1061E8C5,
	0x0B438441, 0x1984AAC6, 0x0B03A9CC, 0x1721A021, 0x1F4038CB, 0x191FAF44,
	0x066CBF59, 0x0786463B, 0x00F597BE, 0x1CACA884, 0x0F3C3142, 0x0BD01DB1,
	0x1D8F1486, 0x0791CC60, 0x04EC01A6, 0x1E538CFD, 0x1633304A, 0x11C93D4C,
	0x0FA11939, 0x046E0E23, 0x1200702E, 0x0B24095B, 0x13FDD270, 0x0D45C6F1,
	0x0D256D9F, 0x10A1C84C, 0x0CE369A4, 0x115C0B25, 0x05D6D5DB, 0x1A9908EF,
	0x11D4E6EF, 0x08B8CE91, 0x14A64277, 0x05EB2191, 0x0AA6BE41, 0x1942ABCA,
	0x0C5F0BD1, 0x16FEDF34, 0x1B23FD74, 0x1A63FFE2, 0x0EE49D06, 0x0D579AD1,
	0x1A06F0E5, 0x00902314, 0x113DF770, 0x0B3C41B5, 0x07A20D37, 0x001CD6BD,
	0x1A4B7B16, 0x1925A6E1, 0x07D93B1E, 0x1BC0FD5E, 0x0F0F000C, 0x003BA3F0,
	0x1B30E0E0, 0x1548E784, 0x003A2CD5, 0x1DBC74BA, 0x0F33E1EB, 0x011E0DA5,
	0x06F07FDE, 0x0A055E78, 0x0748FB01, 0x0D40051B, 0x1A0733DA, 0x15BC0B02,
	0x17C05BE8, 0x07311E86, 0x02675DE5, 0x0220AA6F, 0x1DB8AE45, 0x098E8A30,
	0x0BEA094A, 0x0BC7ACA6, 0x0872C022, 0x01CD4D5B, 0x1055A964, 0x17D5F1E3,
	0x1D2DAA88, 0x0B8B4794, 0x1E3B1A46, 0x1303938F, 0x0C64D3F1, 0x10422E6E,
	0x085111D0, 0x1B82E62F, 0x18B60911, 0x0069C4F8, 0x15F59B0E, 0x0415A915,
	0x043321CE, 0x1F380BA1, 0x0C678EEA, 0x09846C1A, 0x0644C5D1, 0x107EA2D9,
	0x1FE1716A, 0x15663746, 0x0D4F18D1, 0x18347AA9, 0x06022778, 0x09CC3B63,
	0x19023DC5, 0x146AAC85, 0x1EBB9429, 0x1B605D01, 0x18326E1A, 0x15F78301,
	0x1174A925, 0x169FC342, 0x042B23B2, 0x1367B886, 0x091722BD, 0x092175FC,
	0x02505674, 0x00402C8F, 0x0BC86A49, 0x077C498B, 0x128E4309, 0x1807E06B,
	0x157E0980, 0x10DB9794, 0x0DCCC457, 0x0CB85F1A, 0x1333B98E, 0x10A52DF5,
	0x18548D36, 0x1689FCE7, 0x0EE50B1A, 0x0877349F, 0x13B420B0, 0x068417DB,
	0x1E84D597, 0x1F81C66F, 0x00D4E73D, 0x0C99481A, 0x18B932E3, 0x19C5AF9D,
	0x1AE86BBB, 0x1DC24B5D, 0x08156AA8, 0x0E539EAD, 0x1227331E, 0x073906C0,
	0x04EB3F16, 0x10947442, 0x13D02F6C, 0x0E37C80C, 0x1C8346A7, 0x0000823D,
	0x1ACCD133, 0x0707F922, 0x1696A57E, 0x1F4665A6, 0x075200C5, 0x1076E452,
	0x1685EC82, 0x14AB0CD1, 0x055B54D8, 0x18048FC5, 0x0CF7B1F3, 0x1D578E2E,
	0x09840362, 0x1A7CE28B, 0x0F1DB1F9, 0x11F7BAE1, 0x1E1D41F5, 0x00791478,
	0x1CB1D8E3, 0x1EC2B135, 0x19A87CDD, 0x1CD4FCEB, 0x11F11664, 0x1B31503B,
	0x17844684, 0x11B94C39, 0x150CADDA, 0x0468F7AE, 0x0F5E8DFB, 0x099F41BA,
	0x06113781, 0x07E7089D, 0x19B8CFA7, 0x0B456EE3, 0x00E6A21D, 0x0425BC0D,
	0x19C7D4AA, 0x1A5C2013, 0x1789F7A2, 0x1352908B, 0x1E958EF7, 0x132FDC0C,
	0x0EF09152, 0x1EFC7315, 0x0EB1875E, 0x1ABD26EA, 0x1A392CD7, 0x1125C37A,
	0x1CA51244, 0x1069FE1E, 0x09E7EE05, 0x16F5B531, 0x1AAB7B7D, 0x12D3A2A8,
	0x0EA621EC, 0x161F009A, 0x0639B0D2, 0x0D096AFD, 0x148F4CD1, 0x0E3CC465,
	0x0041B86D, 0x12F66E0A, 0x00CB22C0, 0x0D90BE21, 0x07E5A518, 0x06DAED83,
	0x0B2099F8, 0x1EB9F26A, 0x1E870907, 0x01653302, 0x093286AC, 0x0BC226CA,
	0x15261261, 0x00AAE985, 0x1618A953, 0x0580D29B, 0x19C8F584, 0x10CAEC03,
	0x0814599C, 0x045A105C, 0x18200D6C, 0x161CB2C1, 0x159E7BBC, 0x147AA1F1,
	0x1C70CECC, 0x01E2BF71, 0x031D8E90, 0x139A0203, 0x1AEDFA11, 0x10B33042,
	0x00A6900A, 0x0826445E, 0x03275BF8, 0x1354ACC1, 0x086B48C4, 0x03680346,
	0x02B5308A, 0x1C722871, 0x1F7676D2, 0x0DD51A7C, 0x0309989F, 0x0383ED45,
	0x041DFD67, 0x15DF939F, 0x17DD1D4A, 0x0E6C6A21, 0x1DB7FB3C, 0x0E05F3EB,
	0x0170D310, 0x11B67E80, 0x0FC132EF, 0x0A6B3FFF, 0x00647DC8, 0x0616B62A,
	0x07A562B5, 0x164ADB6E, 0x0FF71708, 0x10C44FA7, 0x01CECF9B, 0x033F5B0A,
	0x085DB43B, 0x118BD3D5, 0x0492C34D, 0x0E0040CE, 0x0FFEE3E4, 0x0D6353E6,
	0x1B6FF1C2, 0x0D34D764, 0x0656958C, 0x125030D0, 0x10E313A1, 0x177D5E94,
	0x0AC3670C, 0x101A301C, 0x1B4B8F68, 0x0B03C3D4, 0x0820243B, 0x06FE389F,
	0x0BB7B049, 0x0F47A549, 0x03E335CD, 0x1F42D9B7, 0x0F90EBC8, 0x19918C80,
	0x1A431551, 0x1FFEB54C, 0x11A382C3, 0x02F3B735, 0x1B864E57, 0x1DFD8CD8,
	0x0716B916, 0x0E073093, 0x10164E2C, 0x0F923D28, 0x16B1D8E2, 0x06804D93,
	0x0BA8C07B, 0x1370D3F4, 0x001BFA7C, 0x18F3FBDA, 0x0E0A5B5E, 0x1D56A2FD,
	0x0DCC2E31, 0x12B1836C, 0x04FC787A, 0x18885B8E, 0x08D9CBFF, 0x1D8C01D5,
	0x134468DD, 0x1EDC98FB, 0x149D1641, 0x0E52D0A9, 0x10EF9D3A, 0x1A89FA9F,
	0x15E07BB8, 0x1E5871B6, 0x088FE4D4, 0x01516CDD, 0x198B2D35, 0x1702BFD4,
	0x04AEAD76, 0x046EBEE9, 0x0295E46D, 0x023E4D7B, 0x0B011032, 0x1DA27D84,
	0x03A52ED9, 0x04355DCF, 0x15746E5C, 0x0528D19A, 0x036CFBBE, 0x0146BFF4,
	0x0809FF9A, 0x0B4603EB, 0x1926BABE, 0x1A1759D5, 0x1222FF57, 0x03D66F9A,
	0x1B16F904, 0x16EB8FE2, 0x1F2518C4, 0x05F9D8B2, 0x17BB2BA0, 0x1BDDF394,
	0x1CE7025A, 0x03AE3D07, 0x04930609, 0x1D2725D6, 0x0A23CFFF, 0x18FAFD16,
	0x1561E985, 0x141AD8FE, 0x1ACF4F04, 0x0AA3D49F, 0x06BA9800, 0x1CE331CC,
	0x1009D5EB, 0x121C46C0, 0x0FC0DAF9, 0x1EFCC6FF, 0x1B8DD1A6, 0x13D4DC5A,
	0x15C70582, 0x0144AEF8, 0x03F02BCA, 0x10CC9FB1, 0x0E6F7D08, 0x1A14D214,
	0x0677BEA6, 0x034D3F68, 0x04D9A69B, 0x1F848B62, 0x02BBF180, 0x1C87EB17,
	0x0446BFBA, 0x060C50F6, 0x161E7E2D, 0x1C6F8AEA, 0x13A3D4A0, 0x173916DF,
	0x1C365E59, 0x1F728DA0, 0x16739029, 0x1FF8C93E, 0x008F29A7, 0x0B6261F2,
	0x00D5A0F6, 0x1C50A957, 0x091E7F93, 0x197AE2A1, 0x00B80BED, 0x19888E25,
	0x099216E1, 0x1760FDDF, 0x06203837, 0x0003EEC1, 0x06FB438F, 0x12BE302B,
	0x041667C4, 0x0F1B4C09, 0x03B57FC8, 0x12B14E71, 0x01A80A34, 0x0DA73169,
	0x11D5F0DC, 0x0F569259, 0x13A7EE6B, 0x001255EF, 0x001EB756, 0x108FE473,
	0x16B39F24, 0x1C2D6DC4, 0x042A54B7, 0x16E5DBC2, 0x18CAFD14, 0x0F8AD843,
	0x0EF4E0D2, 0x14035578, 0x07E6DBCB, 0x075F2F8D, 0x0728FD23, 0x01369B99,
	0x1B9B5AD8, 0x0549A6F0, 0x1E61E559, 0x1CF1C254, 0x08549E75, 0x172BB875,
	0x00FCC85A, 0x0FE6A03F, 0x1747E1A4, 0x075CA98B, 0x1BED9862, 0x196A629E,
	0x06FA73AC, 0x0E6EA0C6, 0x05776A09, 0x1805C12E, 0x17E60991, 0x0D82F161,
	0x117C4EB6, 0x1F6B288D, 0x022FEF4B, 0x1602ACDF, 0x094F2C13, 0x1DB1E556,
	0x171597C7, 0x1E80451D, 0x10341D53, 0x0D243E9C, 0x161D7796, 0x07F1489F,
	0x1F411499, 0x009CC1AF, 0x11029A25, 0x15AF2270, 0x05253382, 0x0A0BD25A,
	0x19C93892, 0x04ECE656, 0x068D371F, 0x17330E08, 0x1E8A1352, 0x1176C03F,
	0x10BDD7CC, 0x1A83D966, 0x0A694D4F, 0x0673A5F7, 0x00BDE86A, 0x1FFC0D22,
	0x0FA78332, 0x0072FC36, 0x19C1571C, 0x0E104A35, 0x1653922A, 0x19EC29F8,
	0x16F0DF0B, 0x15A0A1B6, 0x00D0976D, 0x1ED7ECD6, 0x0FA25101, 0x1E307F2F,
	0x16BE17B5, 0x0BF50186, 0x1B648E33, 0x12A3C9DC, 0x0B71F64D, 0x15D441EE,
	0x1B9B1BEB, 0x150D946D, 0x1067A293, 0x1C807546, 0x0DD23907, 0x011CD0C9,
	0x04EE778D, 0x15705A7A, 0x16A9B859, 0x16342EDF, 0x09D57605, 0x0A7682D2,
	0x0B23E7E8, 0x06C672EC, 0x0145A622, 0x179E3146, 0x1D704004, 0x1D94630B,
	0x1536F231, 0x107B6F7A, 0x1BE70D63, 0x0B39AD53, 0x060D1B8C, 0x0C05B5C8,
	0x00FBF606, 0x0F611D6B, 0x1C375B28, 0x04195387, 0x1EE5DC7C, 0x0C439B01,
	0x0F806CD6, 0x0C2234B3, 0x096EB68E, 0x1A7B3114, 0x1891A745, 0x1B6F880D,
	0x1E03060D, 0x1F9BFBFA, 0x1C011136, 0x19A30987, 0x0E1A13B4, 0x024FB64F,
	0x12F93B96, 0x14DC3ED6, 0x08D82BC4, 0x0D3B4FE8, 0x09556A74, 0x01874185,
	0x0B73DF3C, 0x01A7B8B9, 0x0FC1D999, 0x1E653305, 0x08B19C37, 0x00524BAA,
	0x1D4FA154, 0x17EDE8EE, 0x131CBD4E, 0x0C1E7620, 0x1DD7F159, 0x1E0262F2,
	0x0A6550C9, 0x13E3C1E6, 0x1F07B12A, 0x07D8FDD5, 0x0A127F78, 0x0260DFB6,
	0x013E07F8, 0x056D4F29, 0x0D4FD287, 0x0C00013B, 0x07EA8CDA, 0x0212A4B9,
	0x0293239F, 0x0DEFEAE5, 0x1FE5971F, 0x1CF85156, 0x17655097, 0x0007E4ED,
	0x1A40BB05, 0x1E5CD0AE, 0x0AE50C42, 0x1EF22C95, 0x1AC6214B, 0x0C4611EC,
	0x17449AC7, 0x17AD6FC1, 0x137AA5BE, 0x02BC4639, 0x03E42D55, 0x14F238D6,
	0x1598A177, 0x08422B56, 0x118AFC00, 0x1C688CD2, 0x153840AF, 0x10CA76FE,
	0x17D123E7, 0x081AF0B0, 0x1BB7BA32, 0x0D6B535F, 0x1A306C1B, 0x1E8E4F88,
	0x08E4F778, 0x0E5840CD, 0x07DF359E, 0x12B8D515, 0x18664BAB, 0x1853C378,
	0x04383A26, 0x10FA1085, 0x10CA2410, 0x1A56CFD5, 0x13509B17, 0x1C157591,
	0x1C8B58E4, 0x110B01A8, 0x031D3A68, 0x123093DD, 0x1AFCA807, 0x0A6247D7,
	0x0DC5E7CB, 0x08006FD9, 0x14C58AB9, 0x008A630C, 0x1D3B5ED9, 0x17710A8C,
	0x09DD0E7D, 0x0022763F, 0x1420F108, 0x03F3FA17, 0x040C8B25, 0x1EFF7176,
	0x0B0B1EC9, 0x00688C62, 0x0CBFDA18, 0x17CFC663, 0x04946D05, 0x11C14596,
	0x0387C7F5, 0x0BE906E0, 0x0397C63A, 0x0113A0C6, 0x053F3A13, 0x03FEE0FD,
	0x165A580A, 0x093588E3, 0x03FCF2FC, 0x1129E3DD, 0x00F6D26E, 0x0C78B5A7,
	0x0A7FBDB2, 0x1BA0435F, 0x0D1150DA, 0x076664BD, 0x093B8B97, 0x03C0EEC0,
	0x034CF5E8, 0x1921D545, 0x084CEC6A, 0x0FF1BD31, 0x036EDC94, 0x03E5D9FA,
	0x0EA5E88A, 0x01CC5791, 0x04BB9913, 0x0C4A1CCB, 0x133456F6, 0x010F0703,
	0x14936FE4, 0x1D1C9D96, 0x1F75667F, 0x167D0606, 0x1E8A9D05, 0x1315DC43,
	0x047CDD7C, 0x0293FE16, 0x05A81746, 0x0098263B, 0x11B3E600, 0x090EF18A,
	0x08B46C44, 0x00E9E0AB, 0x03B09421, 0x0E715304, 0x021B8578, 0x1D0F66A8,
	0x0CA000EB, 0x1BE233FA, 0x00A99E0A, 0x0A641557, 0x19F8E974, 0x06DE0726,
	0x01B7D83D, 0x199851BA, 0x1D5CC2B7, 0x13F27A30, 0x1BD470CD, 0x1CA214BD,
	0x0BF827B2, 0x17A7C380, 0x1BC0C2D7, 0x1ECE629C, 0x1CCF557E, 0x0B20EBCF,
	0x005FF9D7, 0x09543961, 0x1FD33A34, 0x13274DC0, 0x16849134, 0x1DE23700,
	0x0ECF4A26, 0x1EF3B978, 0x0C0D00AD, 0x150C0F98, 0x08202B9E, 0x150E1E33,
	0x083C7994, 0x0F0936A1, 0x01DE3891, 0x16B595DA, 0x171FD08B, 0x118446B6,
	0x0439F413, 0x02441DE6, 0x11DD7B05, 0x003B404B, 0x1CC786E7, 0x02E78916,
	0x1C4DEF39, 0x03273299, 0x1A2B3ADD, 0x0E51AC56, 0x04142B8B, 0x0C78CAFC,
	0x1CB520B0, 0x00DB7F10, 0x15D4AD46, 0x02A02AC9, 0x00F87615, 0x0B28053B,
	0x1670A6D3, 0x09E42CFC, 0x0769DC45, 0x01BD28CC, 0x02704D07, 0x1DD77A63,
	0x048EFDB7, 0x07A286A8, 0x0D0E8E33, 0x00CC0DE4, 0x119F7FF2, 0x094FDBE4,
	0x131F9329, 0x0B159FE2, 0x1D3493B2, 0x09B59E6B, 0x166B083F, 0x121E841F,
	0x0C1B49A7, 0x062A0DCA, 0x006A1FA0, 0x07DD28E5, 0x1767C25E, 0x1D25F7DB,
	0x184BE9DF, 0x11CBBD52, 0x09B19903, 0x1CB6BAB0, 0x1DF82AE1, 0x0D4913BD,
	0x126F1121, 0x1564A3D7, 0x17A0C4CB, 0x0BA24BE1, 0x027263C9, 0x019B2988,
	0x0DDC8CD7, 0x16B836D9, 0x18BD3B75, 0x09D0F149, 0x0B8F9DEF, 0x05F51F27,
	0x075A68E6, 0x14167326, 0x11D5A3A2, 0x06F40AD7, 0x17A46801, 0x0E4E5AE1,
	0x08EFB0ED, 0x0FE7401C, 0x127A5644, 0x094AC21B, 0x0EA8D301, 0x1197B907,
	0x08F79214, 0x1EB950A9, 0x06087E5C, 0x05E993DE, 0x0B3415FA, 0x11A21056,
	0x0663F67D, 0x00B3208E, 0x1999C53C, 0x0F94D663, 0x026460A1, 0x11B3FD78,
	0x163016DB, 0x00A13046, 0x0D1767C8, 0x01DD5F64, 0x09028EAF, 0x012F6A38,
	0x1F3C8199, 0x0C72FFC0, 0x0D5EBCDD, 0x0D4A2E67, 0x1AE39759, 0x10C93BF9,
	0x0A6AD7CD, 0x1D128699, 0x049AE658, 0x01CEE611, 0x0B9FCCD0, 0x146A67E4,
	0x06D650BB, 0x197EDB0D, 0x178AE6A5, 0x132ECDBB, 0x08C824A1, 0x05B80D72,
	0x095ABAA4, 0x162D8D9C, 0x117DBEFC, 0x004B50F3, 0x1E7F3C19, 0x1AEACB76,
	0x0F111B8C, 0x13B5F3DD, 0x1ADEDA6C, 0x1D20BEEB, 0x0EA04988, 0x13E35284,
	0x0F2EFC7A, 0x0B2AC8FB, 0x0C701C02, 0x198A08A1, 0x1F9DA8F8, 0x08EEDEBF,
	0x07E9A5B2, 0x10A35B95, 0x1511CBDC, 0x116199CB, 0x1FAAA60F, 0x14D6A483,
	0x0E546380, 0x027F484A, 0x14A2BA83, 0x0F36F9A1, 0x1CBB55C2, 0x086E0A8F,
	0x1CD5D73B, 0x062172FA, 0x0059CF27, 0x06C9083C, 0x0880DF7F, 0x162A30F8,
	0x0E086515, 0x1887DFEB, 0x11DCFE6D, 0x02ACC74A, 0x183490E7, 0x120E0494,
	0x0B175859, 0x0E4DFCA2, 0x0C0E73E6, 0x026C29F6, 0x0C79B387, 0x1E3E606A,
	0x1B56427B, 0x050B6C18, 0x133C66D8, 0x07BBCE09, 0x1C8B1E61, 0x0BF2F225,
	0x1D9CDAE2, 0x01D14F54, 0x0DF04CFB, 0x055BB14C, 0x0C92EA35, 0x16E4D7C2,
	0x1C1A7E46, 0x008977FD, 0x031F1E5B, 0x1E650EBD, 0x15140CF3, 0x170431AA,
	0x027D0D94, 0x0DD48531, 0x0C6F20A2, 0x161152A7, 0x130CCA31, 0x16A431F9,
	0x087CDF3F, 0x14BF1F09, 0x0E4C0768, 0x0D331D6E, 0x124D2B18, 0x0311A40D,
	0x0D51C0AE, 0x1167CD5F, 0x0DF9A610, 0x072F262D, 0x0B7CA1AA, 0x0E8282CC,
	0x1EB00DE0, 0x017530D4, 0x14F4530A, 0x147C1671, 0x0843F7FD, 0x142CA87A,
	0x1C94D751, 0x07B708BE, 0x154CA116, 0x071DFCB7, 0x155FCED7, 0x14D4BA49,
	0x0E55DD71, 0x0DBD6476, 0x0578D0D2, 0x113E8463, 0x146379C8, 0x11DF9441,
	0x1103FAFF, 0x120DCF3B, 0x155E22BD, 0x0DBE3705, 0x08A84394, 0x18B545A8,
	0x0381C0A7, 0x1F4497AA, 0x00B8AEDE, 0x13D1C20A, 0x1314D81B, 0x18D993B0,
	0x077BC691, 0x15DDCB7B, 0x084B325C, 0x1FBEF5FF, 0x18646475, 0x0D87E462,
	0x0FEAEE6E, 0x0925E71A, 0x0970598F, 0x021E2CB1, 0x0DDB4278, 0x12DBBC61,
	0x07ADA18A, 0x0A294805, 0x1F2AA6E4, 0x1A741DFF, 0x0F63A575, 0x09A933B3,
	0x016AAE7F, 0x123011D9, 0x1D8623CD, 0x1BBC0968, 0x06F43C21, 0x03EB7D64,
	0x0529E2C6, 0x0791B487, 0x1F0EDA07, 0x0846D801, 0x11B81FF6, 0x0195166A,
	0x0708D1FC, 0x1C2EFBE6, 0x0867CC70, 0x17948771, 0x17023DD8, 0x11D8D6F4,
	0x053EE4CF, 0x13FC669F, 0x0121FA4C, 0x04B8FA84, 0x146522F4, 0x08FFA199,
	0x11669C2A, 0x060AB1DC, 0x1103A46A, 0x02088BD7, 0x1D9618F6, 0x016075FE,
	0x123F5516, 0x11E4463C, 0x05F18D56, 0x1311BE06, 0x0128F6C5, 0x18E205AA,
	0x08617A9C, 0x018C1AB0, 0x1121BF2A, 0x1A0E9002, 0x113195EF, 0x07C1A252,
	0x13645533, 0x17B6D0D4, 0x0D7A43B8, 0x048F2813, 0x1787042E, 0x086E5D56,
	0x16BC4FCC, 0x1AA2668E, 0x19A0E706, 0x040D69EE, 0x1338ECE8, 0x00DBC6C2,
	0x14340A0C, 0x0EEEBE77, 0x0109F0B0, 0x140360E4, 0x011EF7DD, 0x13D930F7,
	0x113CDC06, 0x1311A83C, 0x0BB3CA31, 0x1B9F0F50, 0x1353294D, 0x01C97866,
	0x11BBB8BF, 0x0DB52A89, 0x119A6558, 0x144B0724, 0x0F91D3C5, 0x1FE4DE57,
	0x046E3934, 0x0F949479, 0x06605D01, 0x0A2C3801, 0x13C1842E, 0x118321AB,
	0x16395D51, 0x1F5F03EA, 0x1154BCAB, 0x0A131A9C, 0x17AE34AF, 0x1DB5F950,
	0x19C7E060, 0x11AFC2FA, 0x1F4638A7, 0x155A62E4, 0x128DD9EF, 0x04EA2EB0,
	0x02AB11DB, 0x09DEB8B3, 0x12BAB127, 0x1FA85E82, 0x14D79DAB, 0x04538CD8,
	0x16050584, 0x10588D5D, 0x1575D0EF, 0x0A585B19, 0x02F66368, 0x17887FFE,
	0x15CAF202, 0x1423E832, 0x11CC4FAC, 0x0CCF8EF0, 0x177B776E, 0x0D3923D7,
	0x0F3508D0, 0x0B88146F, 0x024671D5, 0x1AECF2E3, 0x0C6E8AAA, 0x1565BB7E,
	0x08BC7B2B, 0x1FD78B25, 0x120AFE31, 0x0B5BEDEE, 0x1A1B3589, 0x1F4E7FAC,
	0x12B3F564, 0x0DAA5377, 0x135DB8BA, 0x13EFA040, 0x137B231E, 0x1DF4E1E1,
	0x082DEEDB, 0x007F8149, 0x1B3090AF, 0x14D330DE, 0x00A12ABE, 0x12D81544,
	0x0C101934, 0x15598FB7, 0x0F79F8AB, 0x01A31E9B, 0x06389CB5, 0x1F9D7596,
	0x046460F3, 0x02F03006, 0x0CBFC338, 0x0A5E9FA7, 0x1C746EEF, 0x00415A96,
	0x0966E8D2, 0x1D8187B1, 0x02E43A34, 0x166906FD, 0x0E4A4ED9, 0x157FAFA0,
	0x17690D8F, 0x19563276, 0x154C888F, 0x1C6066AB, 0x08BF6BE0, 0x1885F771,
	0x0B85ED83, 0x033F2DAD, 0x0F8795DD, 0x09D54C66, 0x164FE408, 0x042EDA66,
	0x0B076CB1, 0x157F9E85, 0x02EC4EE3, 0x17537B7F, 0x1E3281FA, 0x1FB9C031,
	0x1DF7A9AD, 0x193F9305, 0x060FB8E8, 0x0D6F0D2C, 0x1714C770, 0x0FD5D473,
	0x11DF3777, 0x0D79A197, 0x1B748992, 0x0ABC2F27, 0x13ED65BA, 0x17EDF900,
	0x10B3A295, 0x1C6FAFD8, 0x073FCC66, 0x02FB04E3, 0x0BFB6C11, 0x0214EE78,
	0x03D87771, 0x14E8368E, 0x0FFA53BF, 0x1120DFDF, 0x040B37FE, 0x1F347381,
	0x03448626, 0x03EB768D, 0x13CA370F, 0x0C5BB2C9, 0x0136641A, 0x12466B44,
	0x1D7ED2C1, 0x1198BB4C, 0x0979A6B8, 0x0AC567FC, 0x0B890390, 0x1EB218F7,
	0x1F65D59A, 0x1610DB7C, 0x1CEFAD07, 0x04E3625B, 0x1742EB8F, 0x16B9D310,
	0x14A73768, 0x1D25722F, 0x0F468EB9, 0x072ED584, 0x108794B9, 0x04226C25,
	0x1F299AB8, 0x18C8AE63, 0x0C8A1DD5, 0x0DB58D16, 0x0F8C9042, 0x1C7A26B9,
	0x0E4C6063, 0x152331AB, 0x11904C42, 0x1A3A8A01, 0x10E08622, 0x187F5CDE,
	0x0CA63776, 0x1E5EAB2B, 0x07AFAFFA, 0x11216EC1, 0x038180F8, 0x04AAAEDB,
	0x1E84ACDC, 0x1F6AFEA5, 0x1570EBAA, 0x01C29703, 0x0AA006A5, 0x022D0284,
	0x1B6B76DF, 0x0FB07694, 0x14EE187F, 0x07A4DB77, 0x0D284F3E, 0x0110BF37,
	0x1615A0F1, 0x16CC65DB, 0x132CE58E, 0x148D88BD, 0x17E4B4FA, 0x0C22710A,
	0x162F4095, 0x16385F78, 0x08938892, 0x1FCBFC70, 0x02252F18, 0x15C21E00,
	0x04B0DE93, 0x181058AE, 0x005F4CA5, 0x036FBA1E, 0x10A40B0A, 0x0B227D31,
	0x1B51B197, 0x1E6096FB, 0x118B4AE1, 0x0C08A2A4, 0x0CCB9A9D, 0x015ECBED,
	0x0E235DE7, 0x0849BB84, 0x0620C1F8, 0x1A92F0C5, 0x07EE4AE7, 0x09928234,
	0x081DA300, 0x0BDC737B, 0x19CA696D, 0x1E0744C1, 0x1BC6708A, 0x14AC8B76,
	0x12D3F6D8, 0x17B47B97, 0x0A837990, 0x1998F98E, 0x012095D1, 0x04DD0BF3,
	0x01F7F121, 0x0E2E07F9, 0x08798CBA, 0x0B307585, 0x0560163B, 0x0EEF9B35,
	0x17528F50, 0x1660753A, 0x121EE042, 0x128C025E, 0x02A03ED4, 0x0F58ED6F,
	0x028CDD7E, 0x19030A12, 0x1AFB8BD4, 0x1709AB22, 0x0607B291, 0x0FD66051,
	0x1E421175, 0x0D7B5D81, 0x1A9B8757, 0x0D88A322, 0x193EEF31, 0x01F70EA7,
	0x01584D28, 0x192A6BEB, 0x08710207, 0x17C96BDA, 0x196EE4AD, 0x13A06C7A,
	0x0D42B778, 0x1CFFAD96, 0x171CFB6C, 0x08EB1013, 0x1E9F533E, 0x08BD037E,
	0x05F07636, 0x1F0779B3, 0x07C72E65, 0x1EA835FF, 0x0100DB46, 0x00833E8F,
	0x1A4B560B, 0x09E51787, 0x096E94D9, 0x1A9549C2, 0x035D3358, 0x0971D5BF,
	0x18BC51A2, 0x14F34D08, 0x0E71761D, 0x1CB87B0D, 0x1A288508, 0x1180B6A8,
	0x018E82C7, 0x0E0BDF01, 0x1B2CA35B, 0x01F28E97, 0x0FB50C65, 0x0AA6456E,
	0x1623E9A7, 0x02105734, 0x186243AA, 0x1C02BEDB, 0x116C4E6B, 0x0F00CD2D,
	0x1CF7C835, 0x1CF34406, 0x1C81BAD3, 0x1C66EE66, 0x08F9139A, 0x1DEF67AF,
	0x1A35AF50, 0x0C01AFCB, 0x0DC3FE49, 0x16EAD1CC, 0x00C1FD05, 0x17B38171,
	0x18E32358, 0x117979FD, 0x1DF64549, 0x14F2F9A8, 0x09A95676, 0x108B9EEB,
	0x1F42E636, 0x03BAFB89, 0x15F8F19C, 0x19DEA61C, 0x18DA7272, 0x08FBFC4C,
	0x1E072BBA, 0x07CFEADF, 0x1630309C, 0x0135DEBE, 0x1100A493, 0x1F22B977,
	0x07876A98, 0x08017729, 0x113DD89D, 0x02293670, 0x0F3287E5, 0x0734587A,
	0x0AF3BA5A, 0x130167B6, 0x17B6A895, 0x172C58B6, 0x14223D16, 0x0CDF67CD,
	0x0CD7BAFA, 0x03EFF24D, 0x1F80BC15, 0x0B99A3E5, 0x084C48D9, 0x1E55A8BD,
	0x05DC5043, 0x135746C8, 0x1105FB39, 0x069FDBCD, 0x016FBEA6, 0x0821F59D,
	0x13838EA9, 0x070F451C, 0x1BAD2495, 0x1891E7D7, 0x05BCDB85, 0x1778B13D,
	0x0954DC76, 0x0D392BA5, 0x1C5AD736, 0x0537E023, 0x0A8014BF, 0x1EA90D75,
	0x05098638, 0x01A0BFA3, 0x0B91C7FB, 0x0CF00A3E, 0x17093ACE, 0x1FF68279,
	0x0329179D, 0x1016D31E, 0x12FDC90A, 0x0C848B09, 0x1619A2CD, 0x016B7B50,
	0x17E15116, 0x196ACADA, 0x0360AB96, 0x19980E3E, 0x0DC0E757, 0x1DE7ACC5,
	0x198398A7, 0x1A4E2CA2, 0x1DE91F81, 0x1543FC65, 0x1E3C9DBB, 0x16F144DF,
	0x0D3359B4, 0x1673D376, 0x1D06FE45, 0x0C10C0EA, 0x1797CC21, 0x1913DABA,
	0x165BA6D3, 0x182DCAF0, 0x11D727AA, 0x1BEB33D2, 0x1650E1D5, 0x136F5301,
	0x1552E477, 0x05F4C574, 0x036D5505, 0x1BC818BA, 0x1915E069, 0x169942F1,
	0x1C1392C3, 0x1AD27A6F, 0x0FBB573C, 0x138B7C32, 0x1E56EDB1, 0x1472D0ED,
	0x174427B0, 0x14F3A204, 0x1600363B, 0x176AEF1A, 0x19B682F1, 0x0ABADCA1,
	0x1E9963FF, 0x16C8A376, 0x14A09490, 0x02218159, 0x186CD422, 0x0A8FF014,
	0x132118EC, 0x026B6D2A, 0x0D2B8380, 0x0B8F3C12, 0x09392EFA, 0x0FADF350,
	0x17749371, 0x116E3B14, 0x1DCF7F50, 0x0352F4CC, 0x0C5C23F3, 0x160D0BF7,
	0x0090171A, 0x1164C8B7, 0x00F4ED18, 0x13CFA1E9, 0x192B687B, 0x16E187FB,
	0x1E873214, 0x0EB9E670, 0x092909EC, 0x15AE2239, 0x10602445, 0x109C4B48,
	0x1BEFCDEF, 0x19DB2A49, 0x18B07E45, 0x0A54660C, 0x06CC5A2F, 0x1CE6B878,
	0x009D555A, 0x047DAC6B, 0x0A21DF64, 0x1BE6E7D5, 0x1B6D137E, 0x0EBD58C6,
	0x07B5501A, 0x1862AC01, 0x0B9C29F2, 0x035010DF, 0x1F551D76, 0x157C902F,
	0x011E0907, 0x0C7555AC, 0x15CBEC24, 0x1E4B10F6, 0x1704DEF1, 0x1137C8B1,
	0x0733AF31, 0x18612AB7, 0x0481545C, 0x038C0C39, 0x18C639AC, 0x1782B476,
	0x1B185D93, 0x10A677ED, 0x1AADE22E, 0x1BCCB7D6, 0x0A112273, 0x0C5ABCBB,
	0x01214B39, 0x16448B26, 0x05CA8E29, 0x0DFF8435, 0x10BDBEBA, 0x17967227,
	0x08164A40, 0x0B4699E3, 0x144B8153, 0x1EA73B2D, 0x130EEF70, 0x00078048,
	0x1CF951ED, 0x030BEE5C, 0x1B157279, 0x014A113B, 0x01F91716, 0x144E2F7D,
	0x14953831, 0x11A69D03, 0x181BE406, 0x1D28601F, 0x07130FE6, 0x14A6BC2D,
	0x182E9CD7, 0x0044A295, 0x1B87B8F4, 0x066A38F3, 0x0C0B8A3B, 0x1EF10997,
	0x0EAA1E63, 0x07EF4E70, 0x09BFC7B7, 0x158F976B, 0x082E3A22, 0x0BD9789D,
	0x1C2887B3, 0x1BB34DDE, 0x0EDE4516, 0x1D192D8E, 0x02895BD6, 0x07058AC1,
	0x17C6BBAF, 0x0FD4A3AA, 0x17B5CC27, 0x15789F22, 0x1437C345, 0x10731CD8,
	0x1EF80D02, 0x08BEFF1E, 0x1206CDDB, 0x0D40E15A, 0x0CAEA674, 0x11AB0682,
	0x03B52531, 0x0AD67EF3, 0x1668456F, 0x1A8D1951, 0x04C23E20, 0x0A9E4F47,
	0x06B96D92, 0x099A6ED6, 0x1DED2E8B, 0x1967475A, 0x076705F6, 0x1D86DCEE,
	0x0AD2CD17, 0x1700A6C1, 0x1E545FDE, 0x139BEA7A, 0x103AA188, 0x087E1FAC,
	0x13514AC6, 0x0DA5361B, 0x1F282DCF, 0x18DCAB95, 0x0C774137, 0x01D10B95,
	0x09766BA8, 0x18D0AC16, 0x1B30F336, 0x1A51E857, 0x0CE90822, 0x03A7D1B7,
	0x00D04620, 0x0AFFE133, 0x0CE0AF5C, 0x1149B079, 0x1FDFB020, 0x1C878400,
	0x16A50235, 0x06A80BA0, 0x0020F2FF, 0x07970D64, 0x04F2D452, 0x07EAD941,
	0x0118DC4A, 0x16D415B6, 0x155C6E1D, 0x1A5DB17B, 0x10739709, 0x1FE319A1,
	0x163A0548, 0x11B78EE5, 0x0166F551, 0x0734DDCA, 0x0DFF61E4, 0x0577C350,
	0x19EF8F6A, 0x1AA4A245, 0x1BF49D7F, 0x167D9A25, 0x10E38F51, 0x014CA6E7,
	0x040994ED, 0x1D2794A4, 0x15CBC245, 0x01AB0722, 0x1E96F99E, 0x05C5DCA8,
	0x0F77229C, 0x0E490FD1, 0x1EF28167, 0x02F63073, 0x0FB0BFA1, 0x0C54780A,
	0x1CA356F9, 0x04627C28, 0x055FF33C, 0x1C519866, 0x1778F0E8, 0x06A4654B,
	0x099DA5E4, 0x1D7B0F3D, 0x115EBC2E, 0x1642AD61, 0x15633661, 0x082D7852,
	0x05959E24, 0x08A30602, 0x0950FAC5, 0x0C27ADA0, 0x1B957732, 0x0484B1B7,
	0x158E01D6, 0x011D5965, 0x1B872EE6, 0x12AB324A, 0x10CFAC59, 0x170D7A7C,
	0x1D3E0E99, 0x0774DC0C, 0x13205305, 0x031E971B, 0x1183CC85, 0x03A8FFE5,
	0x1834DB78, 0x06EF3396, 0x16C6F2E1, 0x09EC87D1, 0x0FBE3BAE, 0x1221E45B,
	0x12A8E41C, 0x162D62C1, 0x01956EF0, 0x1E510135, 0x0F255184, 0x00B99CAE,
	0x1D8F55D9, 0x054DC7AC, 0x0EB2D4F8, 0x05CE9F25, 0x16E49FBB, 0x1A82F4BA,
	0x158F1EC8, 0x087F5711, 0x0A65CF7A, 0x1382CC3A, 0x079E0F84, 0x1020889F,
	0x1639D408, 0x075669DA, 0x1C277D75, 0x1159C455, 0x04CDEC6C, 0x08DBBF42,
	0x1E98A1BB, 0x0DDBB9C2, 0x1C6CD39D, 0x0B170E7C, 0x1C369071, 0x15848673,
	0x11C1FB6C, 0x18524178, 0x0ECC86B0, 0x1646E5C3, 0x1BB0D389, 0x046F2800,
	0x1C65E936, 0x1958699F, 0x0B074163, 0x10FB8E48, 0x18E1DEB2, 0x0F0E0A9E,
	0x158130DF, 0x106871FB, 0x0C8588D1, 0x005A18CB, 0x02923D4F, 0x0EEBD467,
	0x031EE2B5, 0x033177AD, 0x0E3A1CDC, 0x04EBBD6D, 0x03C7D8A8, 0x00A45B61,
	0x0F63235E, 0x0B569EA1, 0x137E7C7E, 0x09F998D6, 0x1EADD7E6, 0x15CB21FA,
	0x0E03387F, 0x0BEC09C9, 0x0EF55316, 0x1EE5051B, 0x1064BEB4, 0x18EE6F10,
	0x0B74CA9A, 0x049DF7FE, 0x1A1EE3A0, 0x0854EF9C, 0x139EF433, 0x0CDD2868,
	0x0F169ED3, 0x05B5C6ED, 0x0557B026, 0x04134615, 0x0E8A7399, 0x07022D1C,
	0x13B1ECFB, 0x01A88B11, 0x1678E0BE, 0x04A08580, 0x19F28F18, 0x05D6BBF3,
	0x19EC0B84, 0x18C2E019, 0x0C85AB3E, 0x1C7B13A0, 0x0D726B10, 0x16E02E2A,
	0x0AAFBBC0, 0x1F637CDD, 0x0034462A, 0x1E9A7387, 0x12B90CB1, 0x02082484,
	0x1D662178, 0x010CA67F, 0x074403CA, 0x123331E2, 0x09F1708C, 0x07F4DFE6,
	0x0F1FD53A, 0x0237D954, 0x1C9CD7A5, 0x15944FE4, 0x1315BA67, 0x016EAD19,
	0x10A8063D, 0x18FC0881, 0x16CF7A49, 0x150A134E, 0x0E4AD17A, 0x0056716A,
	0x13ACFFC4, 0x12012C6E, 0x1CCA8728, 0x11C52134, 0x1E98EFEF, 0x1761D0EE,
	0x06F244AD, 0x1430AA5D, 0x1E183672, 0x13090870, 0x1587E150, 0x18C32298,
	0x1A6B0835, 0x011A1A25, 0x1818F6D6, 0x138600D6, 0x18F36480, 0x02BEE68C,
	0x0F21BCBD, 0x1DCA1290, 0x00BCFA59, 0x04072A0B, 0x1FF0718E, 0x06658525,
	0x13766742, 0x18FF461C, 0x150BB445, 0x1BCD7C67, 0x0D900600, 0x0F8A6755,
	0x0042D866, 0x1FB212AB, 0x1F085CD1, 0x19A01740, 0x087D1079, 0x177681AC,
	0x09A26177, 0x12AA5121, 0x1D2AF717, 0x15AE8613, 0x059DB3D9, 0x0EEE3AD1,
	0x0BBD0156, 0x1DF4DB71, 0x0B08691E, 0x0BEA7A7A, 0x1CB6E02D, 0x0F1FE810,
	0x194E0A86, 0x08CCFA5B, 0x1F5FFF67, 0x0C9326A0, 0x089E7136, 0x103FD071,
	0x12E21865, 0x112E650A, 0x0E527DC7, 0x10C9814C, 0x15A6041C, 0x1D79A251,
	0x053E89F4, 0x15B0E255, 0x1532DB99, 0x1911168A, 0x1538D005, 0x1C774D7B,
	0x1DA2F49C, 0x14FBD34A, 0x08863ECC, 0x0F11CA34, 0x16D8EE6B, 0x07DED029,
	0x0BDC8A7A, 0x165F5073, 0x0BB2DEA7, 0x06F12BF6, 0x1AAD42BF, 0x095714D2,
	0x18A10B5F, 0x0B108F24, 0x1CD3E263, 0x0F0ED707, 0x13F2F079, 0x1801EFD2,
	0x1BEBD117, 0x0AF6358B, 0x0046E5AB, 0x18591286, 0x17BE115B, 0x1B068F40,
	0x13BD719A, 0x05979EE6, 0x07E72393, 0x0950CE26, 0x0024457B, 0x0BF83D85,
	0x0B815B02, 0x11B02869, 0x0B31AC98, 0x0966FE21, 0x029654FD, 0x1DC6F279,
	0x1FDE984D, 0x0EED841F, 0x04F1E59F, 0x04DA1776, 0x0B88CF04, 0x1CC39EC7,
	0x179A5EA8, 0x1B2B60F7, 0x0D9B1B5A, 0x00524FD8, 0x17DC9498, 0x0E02B750,
	0x0CE16715, 0x1E1BEC0B, 0x0FAF57BC, 0x19A0A539, 0x0D5EF774, 0x063B2F12,
	0x07D843CA, 0x14FF2669, 0x17E89996, 0x16970E34, 0x174181EA, 0x1E527157,
	0x19514E26, 0x011ECA7E, 0x0038351C, 0x141AA935, 0x09564678, 0x063D7826,
	0x03531D7E, 0x10685058, 0x088A3537, 0x1A42C175, 0x017BABB9, 0x0A8ED2E0,
	0x0DA53F39, 0x11DBB276, 0x1C14F8E1, 0x06858698, 0x0D4ADBA1, 0x1C76616D,
	0x07EF0AD4, 0x13189150, 0x0A0019B0, 0x18EB46DE, 0x023CA71D, 0x038D2CA7,
	0x007EF7FF, 0x1B2160EB, 0x029D20A8, 0x17AD246D, 0x0F081F9A, 0x022C1AEF,
	0x0971A627, 0x17D47A9C, 0x0BA9EF7E, 0x08E5B059, 0x1805F6EB, 0x06D3D1B1,
	0x18C148F6, 0x0F8F367E, 0x17694D53, 0x12892045, 0x0FD32F79, 0x0D48DEF6,
	0x0BF6B7EC, 0x0F39CB0E, 0x0C60DC8A, 0x123069A2, 0x01EF2909, 0x112FCC6D,
	0x19B1CD9D, 0x05A5434F, 0x1D4D351A, 0x19BBB084, 0x14A9F560, 0x00B5B14E,
	0x1E9283A9, 0x081E4BC9, 0x1009E711, 0x16F4BF8F, 0x07CE63CC, 0x1E9536AD,
	0x124F7698, 0x10E510A1, 0x038C1570, 0x0EE94F8E, 0x14B30248, 0x07AC6F5C,
	0x1FFED35C, 0x0B9F70EB, 0x1D3E9C55, 0x1AB9E9FB, 0x0B2B0B58, 0x16A9AF9B,
	0x1C3F0056, 0x173B83B7, 0x00A6E7E0, 0x1B53D10B, 0x088B305C, 0x0D350441,
	0x198C50B2, 0x1DD9A679, 0x1EE75F1E, 0x0BD47AF3, 0x1EB8DE3A, 0x1CCB43FC,
	0x1FF784C6, 0x02BB8A51, 0x03BB997A, 0x190EE887, 0x00A0F970, 0x113FFA91,
	0x0CBEF9C5, 0x06D0354E, 0x0AE12748, 0x12578337, 0x04500E82, 0x1210CACB,
	0x1FA1927E, 0x1D799352, 0x1FC8F52F, 0x1628FEF2, 0x10DAF3E7, 0x0A932633,
	0x0F98B791, 0x0A0C93D4, 0x1E54183E, 0x08177BDF, 0x08450FEF, 0x086F4DA9,
	0x1A54142E, 0x059E73B6, 0x0A17B021, 0x02D9C46B, 0x1E07E150, 0x0AF0B3F6,
	0x136D6A96, 0x1CB32C26, 0x14C7E5F9, 0x027D9C2A, 0x1B9CF9A9, 0x0F8706F5,
	0x1E97AF0C, 0x196343EE, 0x0F478C0E, 0x0C19885D, 0x0786B9FF, 0x0CB5671C,
	0x11C30576, 0x0E93444C, 0x0D21761B, 0x0F1F4480, 0x140B3087, 0x12FA8535,
	0x1B4AC7FD, 0x07BACC89, 0x00294A16, 0x04A62867, 0x0E86713E, 0x0DCA3948,
	0x1F45BAFD, 0x11B25DEA, 0x0FDAB89F, 0x08D4C449, 0x1E52130D, 0x0CEC5B05,
	0x0D49A30F, 0x1EDC68B6, 0x15ADBDE3, 0x0477A122, 0x1072F924, 0x087356F2,
	0x09C79B2E, 0x1B2A916D, 0x12E9E492, 0x1D53D8E0, 0x08990F24, 0x19962D4C,
	0x095943C3, 0x14262A47, 0x052682C4, 0x1BDE4145, 0x083A344E, 0x1E70ABE8,
	0x00FD6EC2, 0x1B781223, 0x06166959, 0x15102AAB, 0x1C85848F, 0x14E6AA8B,
	0x119E542F, 0x0B410973, 0x0EAE3730, 0x154B7F81, 0x1BDF479E, 0x1E53BAB7,
	0x0084897C, 0x0A3278D1, 0x08132B9B, 0x15D4EE22, 0x0A88F801, 0x05DC8344,
	0x1E5D6D9F, 0x056E4FE4, 0x16CA468B, 0x0FF0F3DB, 0x1FF7F362, 0x0897586E,
	0x16FCC982, 0x04B643CA, 0x09A82FC8, 0x1BBCA1E4, 0x15B3E8A2, 0x1CC4446A,
	0x0A2A7BCD, 0x1793B257, 0x10EC316E, 0x184C6682, 0x0F9E2274, 0x149CD108,
	0x099728A7, 0x0BCE679C, 0x1D95CFCA, 0x159AF66E, 0x084D4492, 0x1A2B6171,
	0x19AF8051, 0x0D587E34, 0x010D9E4B, 0x117B8CF2, 0x0A99C0C4, 0x1085D74B,
	0x0A415044, 0x1D9410C8, 0x097C5E7F, 0x1F6AB5DC, 0x1A8B16EF, 0x0F0C6FA7,
	0x179A0A8C, 0x04129B1B, 0x0F4C9941, 0x136338FF, 0x0FB445D8, 0x049F1170,
	0x1DBB00AF, 0x0E0557A3, 0x0411BED4, 0x1DCF47FB, 0x07E954AF, 0x1583EFCE,
	0x07172B08, 0x04624202, 0x02C0D844, 0x02AE4AC4, 0x17D8EF38, 0x16822CA3,
	0x178645BC, 0x1197D3DC, 0x0E979DB4, 0x15779A8D, 0x02C5D5EE, 0x00D0374C,
	0x16D7ABFE, 0x0756B3C7, 0x05472AEF, 0x17FB9555, 0x0ECA833C, 0x071FAC4A,
	0x15E83450, 0x18031A42, 0x01207CEE, 0x007E106B, 0x0586BA73, 0x1BC989F9,
	0x1A0C6E29, 0x003E8373, 0x05B96EAA, 0x016E2311, 0x188895DD, 0x13553E1E,
	0x0948C6AB, 0x05B27F36, 0x092FE198, 0x0BC92900, 0x1CA9F9F9, 0x0F96B2C1,
	0x1A1A5DB3, 0x1CB994AB, 0x1D61FF75, 0x1F46F29F, 0x1D3087C5, 0x00823660,
	0x13C2FB17, 0x12C82FB9, 0x09DDF00C, 0x18E69B96, 0x00B13E4F, 0x16E994BF,
	0x09327AB8, 0x0C8FAEAD, 0x1CDB04F6, 0x1BF53B41, 0x1F97D5E2, 0x0906DEC8,
	0x1FF321B2, 0x0A2CE875, 0x043DAE63, 0x004E04CB, 0x1CF9379A, 0x1497E1C0,
	0x167F72F0, 0x1E3B5272, 0x17938118, 0x17B011BC, 0x02337EB8, 0x1A72E4FF,
	0x171DD778, 0x0A7E6856, 0x111A1675, 0x0E061FF8, 0x09B30BA1, 0x103F3DAB,
	0x1086FE9C, 0x1E29134C, 0x056F5489, 0x10ED78F2, 0x1ACB4C17, 0x00F411F7,
	0x02CFDB74, 0x1D6A8C28, 0x0F4AE220, 0x0E2E73FA, 0x100C1E6D, 0x0BFFB3C9,
	0x1C624C5C, 0x16520C34, 0x1D8DD993, 0x1A101B96, 0x07B67390, 0x15C0F38F,
	0x04518788, 0x0574B5B7, 0x0BBE754E, 0x094A36A3, 0x044A92A5, 0x132B09F4,
	0x011477F2, 0x0053EC3C, 0x1AFCB529, 0x15A74536, 0x1F3C1ED7, 0x0724E161,
	0x1F22092C, 0x0E927FC2, 0x1EF2007A, 0x1FF32322, 0x105F5C68, 0x105B1A8E,
	0x04DE8150, 0x145A776E, 0x1B9F2E43, 0x07242DC1, 0x0EC81661, 0x02271EFA,
	0x1FD91435, 0x12B95A23, 0x10F0D940, 0x055103E3, 0x121FD710, 0x15497B6C,
	0x0CF109B9, 0x1F3ECF2C, 0x1E9EFB8A, 0x12CA18E7, 0x05BAA487, 0x06139EAF,
	0x1DF4BFD8, 0x13392E4E, 0x084B7245, 0x09C840C1, 0x16F7E615, 0x0D1E671D,
	0x1653E082, 0x18EDF397, 0x09439950, 0x01B2E98C, 0x01182D34, 0x083901E1,
	0x11C88A2C, 0x0C7D2671, 0x01D1619E, 0x1A151C0B, 0x1C6BEF1B, 0x0427CEA8,
	0x0ABBD0B1, 0x092A14BE, 0x139733BF, 0x0CB71029, 0x096E768E, 0x190DC29A,
	0x180AEB4A, 0x0B1D9FCD, 0x1C32B6D3, 0x12E42BEE, 0x0338C5A1, 0x0FB2BB28,
	0x16E7A8FE, 0x072F8714, 0x0DB14E80, 0x15D59358, 0x0087EB37, 0x1282591B,
	0x078398E4, 0x0B2D3682, 0x029B7913, 0x10E25773, 0x0A6177CD, 0x0BC07967,
	0x1373DE18, 0x1DD8537C, 0x13A59D1B, 0x0CF0DAAA, 0x0E70824F, 0x095A1440,
	0x006DB117, 0x17B07F6F, 0x103F65DD, 0x0127CE3C, 0x1FEEFBBF, 0x004B6FD1,
	0x0AF77C19, 0x04732A91, 0x15A940A7, 0x0620B730, 0x07747A11, 0x18CDC8A7,
	0x161CA8B7, 0x12367A92, 0x1412DEBA, 0x03A2DB17, 0x12960964, 0x08AEA9B2,
	0x100C6228, 0x002C4DFC, 0x022B86A2, 0x04290E67, 0x10B44D4C, 0x16D8B5EA,
	0x0FF957F4, 0x1DC9D7B2, 0x04109971, 0x0A425A77, 0x0877C1E3, 0x171E9985,
	0x0515834A, 0x0687368F, 0x04F6A95E, 0x1D934068, 0x0480936A, 0x197F4899,
	0x088AF1F7, 0x1A7A0A7F, 0x058467E3, 0x11FF9816, 0x0A1A0999, 0x04E1AF1A,
	0x1392C67A, 0x016C195E, 0x1B38C5D6, 0x1AC849ED, 0x135AF223, 0x16552159,
	0x0FDB3D4A, 0x092102B1, 0x0EC2B0C9, 0x02AC9DA8, 0x0E7753FB, 0x12D59087,
	0x1256D1AF, 0x1E7FF329, 0x0922D4CF, 0x0D542DA2, 0x00C6EBA6, 0x134EE683,
	0x1219C19B, 0x0336A07D, 0x15DA50D7, 0x1336AEC9, 0x0A0E4D81, 0x0F73A2C4,
	0x0A7FF7EC, 0x0C070639, 0x0A4AF5F1, 0x012805A1, 0x0A5E56C2, 0x168E84C1,
	0x1F4F0B83, 0x0B3A6B62, 0x01890D55, 0x1E6E7FBD, 0x11449743, 0x05DFAAA2,
	0x1DF0BA1B, 0x08F56707, 0x1C05EC5E, 0x1EEB6FC7, 0x0E4915C0, 0x14A2CADE,
	0x1C07ECD4, 0x1EC113D7, 0x0EE57C58, 0x1AE7DBF2, 0x03C8C6D5, 0x1D842DA9,
	0x060A1893, 0x19D1E455, 0x15A8987A, 0x132DFBEA, 0x15EF05C2, 0x1798BF3E,
	0x10522DCC, 0x1C7CA0DA, 0x1EB6C64E, 0x13D7A4BF, 0x066821C5, 0x1B4545BE,
	0x05BAAA22, 0x149F8FCE, 0x0D03CD85, 0x16587B7B, 0x0822EFF8, 0x0D68592A,
	0x0F57163F, 0x065C67EA, 0x165F1A5C, 0x03732297, 0x0FACD7CC, 0x10E11D6E,
	0x028CE474, 0x14D190F5, 0x12213D20, 0x176EA119, 0x1B4DFC0B, 0x0AE60AA8,
	0x10AF7D32, 0x186D9BD4, 0x0802FAFC, 0x1B620CAB, 0x0298042D, 0x05B90D79,
	0x13F3A552, 0x19435FFE, 0x00ED1984, 0x0DF65439, 0x05F2D31D, 0x108A7823,
	0x1990244C, 0x0561B48D, 0x18EEA4DF, 0x0424E0AD, 0x1A06B78E, 0x014B3A59,
	0x0B962F52, 0x1C7A23E7, 0x113C6FDA, 0x0B30FB5C, 0x0CD672A2, 0x01FD4989,
	0x11F29348, 0x02E7FF04, 0x0F6862FE, 0x1B4907F3, 0x1F84204D, 0x1781B93F,
	0x0F76F9EC, 0x16D4A9DE, 0x024E3B81, 0x0203D0E6, 0x086584BF, 0x065937E3,
	0x04B97627, 0x0E54BF68, 0x1E4C7325, 0x1769CE78, 0x09D3E6F1, 0x002B1A34,
	0x18A0787E, 0x00B6B5B9, 0x0AA34462, 0x0A7C9CD8, 0x179427FC, 0x1C11CD5B,
	0x0B6861D6, 0x169F4983, 0x08ED1E79, 0x18A643F4, 0x0A75BEAB, 0x05A11F9E,
	0x024ED298, 0x116C7018, 0x1B628778, 0x1E2A18D1, 0x19F4AC0F, 0x055705E1,
	0x1997B509, 0x1C3556A4, 0x0156E8C1, 0x026B8D34, 0x0E7627AF, 0x00145DEF,
	0x1F3349D6, 0x179EBAA2, 0x070E6A3D, 0x124364F8, 0x08B75935, 0x1F40E6FA,
	0x16029323, 0x12CA3298, 0x1BEA1C8C, 0x113CAC9A, 0x1399D1B6, 0x12209D1D,
	0x180FD48E, 0x1CAFB536, 0x1510A46F, 0x1D8A89A7, 0x13CE4619, 0x00F7FD83,
	0x1B3831EE, 0x094FE492, 0x17D4D27F, 0x1FEC4096, 0x183ED134, 0x10303BDB,
	0x11FDAD8C, 0x158C5C3F, 0x09358988, 0x17446982, 0x03A9C20E, 0x0EECACEA,
	0x1A892FE5, 0x12474944, 0x1F85CE86, 0x0BA6E4E1, 0x137DDE49, 0x1AAA62B2,
	0x1F27C001, 0x0D44BE74, 0x0A9E213E, 0x15851697, 0x139B44AD, 0x0F1F2316,
	0x03661DF5, 0x090A8B02, 0x1498A40E, 0x095CC013, 0x0F5B0497, 0x036A6DC5,
	0x0ACF8E48, 0x1EFDAB1C, 0x168F6DE2, 0x0C748A96, 0x1408AD34, 0x12C8AA30,
	0x0167048F, 0x0B0FADE0, 0x054BC7A0, 0x07E40593, 0x15F1D362, 0x177EEB6A,
	0x0ABC4942, 0x1FD45653, 0x18F2E046, 0x1AEF6CAF, 0x0D56E999, 0x11FCCD18,
	0x07D0604C, 0x0F44EC81, 0x053482C8, 0x17C65BE7, 0x17634D05, 0x01CF8159,
	0x1218702D, 0x057A9C6E, 0x133AF0DC, 0x0CCA0682, 0x1BB0D43D, 0x18E28226,
	0x1E6F2099, 0x1430533B, 0x104D5497, 0x086BA0B6, 0x162D8ABA, 0x0E209C64,
	0x079A32CB, 0x1298A845, 0x1A77C613, 0x00FB3E3E, 0x1A3DC219, 0x06F304DD,
	0x160DA04B, 0x157CD2CD, 0x1BD62D8F, 0x197E6299, 0x0EF4F703, 0x1799E69D,
	0x11EE64A0, 0x0A40050E, 0x056BBA62, 0x04EFDA52, 0x0592C6E2, 0x05B3DA60,
	0x0CD0DCB8, 0x00E3552C, 0x067CCE56, 0x02802DE4, 0x0379CD99, 0x13EDA960,
	0x0CECBC44, 0x0D4DE80E, 0x0F14FAB3, 0x05F60373, 0x0FC4B5E1, 0x0F0C9165,
	0x12A23F50, 0x00E6B41D, 0x12ECD627, 0x049FFD5F, 0x0F5F7F26, 0x03B38A85,
	0x18B8BD00, 0x1466BE26, 0x0743701B, 0x16AED86C, 0x083437A4, 0x11782205,
	0x0C13CF22, 0x084189EF, 0x0503C538, 0x14B10A22, 0x01BABE9E, 0x15666C58,
	0x0506A334, 0x1297685F, 0x0B5F30D6, 0x0F2A85F0, 0x17E49FA2, 0x0E22F5B2,
	0x03C8C450, 0x0A305D4D, 0x19401F3B, 0x080174B3, 0x1708F4EA, 0x1A8F8603,
	0x1427B706, 0x035A33D9, 0x0572F7B9, 0x0056B564, 0x1400891D, 0x1B952FC0,
	0x00DD99B0, 0x0929E9C0, 0x06676F10, 0x14146AF4, 0x0634DF0B, 0x05BC405D,
	0x0BA19F05, 0x0FE190A2, 0x185D6396, 0x0D349CC7, 0x01D5AB84, 0x06131F41,
	0x0101DECD, 0x116C7C56, 0x077E9C42, 0x0FA92BB0, 0x091C3214, 0x1852A6AD,
	0x1DEF8EA5, 0x1DB7B24F, 0x0D131A69, 0x1FE7D6C7, 0x10E666F7, 0x0B98ED80,
	0x0A971B49, 0x0E0EEBA6, 0x0BF9FA3E, 0x1543A092, 0x0C077798, 0x099BDD72,
	0x0D014F4F, 0x0248A847, 0x1CD9723A, 0x1287649A, 0x1AA0763D, 0x0D74DE89,
	0x1B2EFDCE, 0x0CB9F6A9, 0x03A1C7EF, 0x0B82845B, 0x07E35CA1, 0x0546BE02,
	0x0B723A5C, 0x1FEF6607, 0x10397A2F, 0x1633E133, 0x1143877F, 0x0B25EC02,
	0x0060D87C, 0x17CBAAA6, 0x09BADFB1, 0x13714B59, 0x00B9CDFC, 0x14D5A2ED,
	0x12B9EEA8, 0x04D6A720, 0x095179E8, 0x0EECBCA6, 0x1F42DC0E, 0x06C57350,
	0x06204E88, 0x0216865F, 0x03617EB2, 0x0A2962BD, 0x0908AEDF, 0x1E406F15,
	0x1A9ADEEA, 0x15EA68D1, 0x04A77EDD, 0x1D1331F9, 0x037E7BB1, 0x1EDF99E0,
	0x0A776519, 0x12DB1C83, 0x08907C16, 0x17D9D307, 0x0A8F619F, 0x05C438F2,
	0x0B28B862, 0x068550D5, 0x1675AF65, 0x0456BC72, 0x0AF4CA42, 0x06CDA74A,
	0x0A253231, 0x0249EB17, 0x0B0573FE, 0x0CA663F7, 0x14061AE0, 0x01401D07,
	0x0C985699, 0x10AD6E7E, 0x06E64382, 0x16E428E3, 0x107F297B, 0x03B2F959,
	0x18363911, 0x1AE0533E, 0x0BF5E78A, 0x1DF8ABA8, 0x0690DFE9, 0x18ABEC59,
	0x082BC5A1, 0x06DE3AFA, 0x180774BA, 0x04B6A46E, 0x0186ED2F, 0x1242B43D,
	0x0DA1EA23, 0x0028F87A, 0x1755849B, 0x145E5D2F, 0x170065CB, 0x1778DB3F,
	0x156E01A5, 0x1F694080, 0x14B719EE, 0x1F9CA62F, 0x0B389683, 0x1BBD333A,
	0x0C2059DB, 0x1C78AE52, 0x08BC98BC, 0x062E48D5, 0x192716EB, 0x1CAB8240,
	0x1E2FD5D1, 0x13B60CD1, 0x14C6FC89, 0x1AAC5F66, 0x05D86426, 0x1F676911,
	0x18CC1E19, 0x0093D5FE, 0x05B0304D, 0x05198A02, 0x0A0C513D, 0x1A6E4829,
	0x03D79208, 0x13406555, 0x1D84D5D7, 0x0723FC4D, 0x182A9AF8, 0x0749B38A,
	0x12409FB5, 0x106C7BF3, 0x0C21F397, 0x040D7A5F, 0x185E7159, 0x051A6794,
	0x1E33F497, 0x164642D4, 0x03CF3F06, 0x114FCF4A, 0x1F68292B, 0x02C8E624,
	0x03CBEBE9, 0x0ABEC36A, 0x14358E78, 0x0106836C, 0x13A0F55E, 0x0992345D,
	0x09CDE5C8, 0x182ACC80, 0x182A0E6E, 0x0EA6BC5A, 0x0AD8FE00, 0x06857D2E,
	0x0BDD3633, 0x19A22B70, 0x142F210B, 0x0099F30E, 0x1E3E8FFA, 0x0BFD48A6,
	0x0163B9F5, 0x1803E977, 0x05A37F88, 0x11379E1B, 0x03B6DEA2, 0x11119753,
	0x1830033F, 0x17008E25, 0x1DDE787F, 0x04E9CE9F, 0x0CDC73AC, 0x1D7383FB,
	0x0B269E4C, 0x17238520, 0x04A22EAB, 0x19987616, 0x0DFC7A79, 0x1CBF7456,
	0x0D4D39DF, 0x0D170AEF, 0x0060B24B, 0x0DAD5B80, 0x14D5DA4F, 0x197D54D8,
	0x16FFCD92, 0x00F21520, 0x07C4C379, 0x10790C2A, 0x10809B22, 0x11EB10DB,
	0x08FCC605, 0x10C7E0FE, 0x1F7BC07A, 0x0997CB71, 0x1DF927FC, 0x027D1C6D,
	0x1E6FD667, 0x1291EF8A, 0x1DDA5CF2, 0x0E113B9D, 0x0D8C1F50, 0x0BCB5F3D,
	0x1CC99ADA, 0x02C15F19, 0x0CD5C01B, 0x12BCC3F8, 0x1E259F31, 0x0BB9902F,
	0x1B3A0BAB, 0x11A8E117, 0x08975BBF, 0x0EF88383, 0x0BA1ADC6, 0x03EFB0A9,
	0x027D1EFE, 0x04839D11, 0x1E21A840, 0x04C8723C, 0x1FA78078, 0x10AACB14,
	0x1A50B146, 0x1DE4458F, 0x0D29D716, 0x1A93202A, 0x02C2376E, 0x18883F9C,
	0x06D7D087, 0x0BA0F9E6, 0x182319EC, 0x0B736C5B, 0x0F362516, 0x108B6C8D,
	0x070D07D9, 0x1615F8F0, 0x0F96E6D2, 0x1F6FE105, 0x0170F6AC, 0x0B98860C,
	0x0D546E25, 0x103DC39C, 0x04F84747, 0x14076C56, 0x08830690, 0x1504ECC7,
	0x0061DFBB, 0x1ADD6405, 0x081EC3A1, 0x06DBD9A5, 0x137A34B2, 0x105B5F15,
	0x1CE56304, 0x04AB50B2, 0x086676CD, 0x048891EB, 0x0BD9DB0F, 0x01877AD9,
	0x0CC1FF41, 0x0FE559DE, 0x0FA0ABEE, 0x0BE19654, 0x19AF8060, 0x154C4985,
	0x04A98895, 0x13F0E704, 0x140D5A35, 0x0FD7D6F3, 0x17B82739, 0x1236421A,
	0x1D9C9BD7, 0x14A59B64, 0x1B3910A5, 0x1858477A, 0x1F950C0A, 0x0DEAF78F,
	0x0F3D0E1E, 0x0AF3F085, 0x11CE0D2B, 0x1B94ECA7, 0x11DC3225, 0x17590F5C,
	0x0358A2C6, 0x1FF55B2A, 0x0C99B91C, 0x04A72168, 0x1128BBF0, 0x1810DB06,
	0x1A7A37CB, 0x0CF9C4E1, 0x0150DE23, 0x15E59432, 0x1D09D7DB, 0x1CB2990A,
	0x1C74FC9B, 0x1BCE44F9, 0x0A6DEC66, 0x07AF0B53, 0x1E3F1FC5, 0x1EDA1C71,
	0x104B9A2D, 0x053814CF, 0x0B3107A2, 0x0CC72E04, 0x1CE609BE, 0x0E68737F,
	0x17B3F665, 0x1160B4B8, 0x1DEF2B2F, 0x0DF40DEE, 0x01FADBF3, 0x000DA765,
	0x11F6D4C8, 0x0B28F71A, 0x09DC3F07, 0x1B0EDFD8, 0x00D7B211, 0x0A4CE3C6,
	0x0B70C27C, 0x0D5FE4ED, 0x10C49AFC, 0x15376392, 0x174D4213, 0x0182158F,
	0x17CF8712, 0x07FDA1D5, 0x0537E615, 0x0B287E87, 0x01DFE7EC, 0x183C4F39,
	0x1E4BAB6B, 0x0B6B14E3, 0x08629D13, 0x118A606C, 0x145CABB5, 0x015547E0,
	0x118A51A3, 0x0C6287A1, 0x14713AE9, 0x060433D9, 0x0FD2F349, 0x183DDC51,
	0x0A8E97F3, 0x1E0432F1, 0x00DBE8EF, 0x12687B4A, 0x1063BC67, 0x0D4B9935,
	0x0224494D, 0x099AD28C, 0x10C972C0, 0x1709BFF8, 0x01BC159D, 0x076F0C5E,
	0x080AE3C4, 0x03E3B4DF, 0x02D3DF49, 0x0429C7B0, 0x183EE639, 0x194D81D8,
	0x1EA11387, 0x1A0C36CF, 0x06BAC528, 0x17A29FBE, 0x09959890, 0x0249E5CF,
	0x0BD52394, 0x18000C4B, 0x072C73F8, 0x0DF68F29, 0x1C45CAD9, 0x16F47960,
	0x189CA804, 0x1C126694, 0x16927757, 0x06B5DE74, 0x1D076AB1, 0x1CA22048,
	0x17DACBCE, 0x019FB4F8, 0x1E3EFF9E, 0x19AE3D79, 0x0AE10041, 0x1E272178,
	0x05644881, 0x1C11F966, 0x17B41C78, 0x01727CA1, 0x1508E861, 0x1F023738,
	0x0D243BDE, 0x0CDC450A, 0x1D279474, 0x19EC735F, 0x074444BF, 0x05D36C47,
	0x1F3506B8, 0x116577F4, 0x09386632, 0x0A9AF581, 0x056AE283, 0x1F62C14A,
	0x0FC71FBA, 0x1BA4B5F9, 0x1D0C2442, 0x1A88CF10, 0x0B81E4FC, 0x03FFDA60,
	0x1EE29CA5, 0x03DBFC5B, 0x098B9E24, 0x0FE94602, 0x1191E30F, 0x0F3B676F,
	0x114DAED7, 0x0AB6DF89, 0x1651035E, 0x1F487393, 0x0D3E8BB6, 0x11AE9BE0,
	0x0741CA97, 0x10F5E96D, 0x00AC32DE, 0x1F121137, 0x1FE97AFF, 0x1B26B264,
	0x1E799D92, 0x107DF56B, 0x1B5F07D4, 0x0E621667, 0x0B0D2151, 0x091A6966,
	0x15BA9005, 0x13255502, 0x184DD3D5, 0x07FFE612, 0x14ED55CF, 0x13855E5C,
	0x1B5C106B, 0x1927AC3A, 0x1FEE46AC, 0x148B3DD5, 0x14D9D6D8, 0x0F6F5972,
	0x0BB06B44, 0x002FFF6F, 0x04F3DADF, 0x17A3C3F2, 0x0CF6EED9, 0x087E78F0,
	0x032F6787, 0x1D55ABD7, 0x019992EB, 0x09F18AC7, 0x184AB560, 0x032BEFC7,
	0x0EE5AD3D, 0x026F6798, 0x1527378E, 0x1B1D0E17, 0x1513D45D, 0x0061010A,
	0x1F7A1730, 0x1DCEB0FF, 0x1A6EC3EF, 0x064708AF, 0x0E6B9BA0, 0x01F1194E,
	0x0B85F3C6, 0x00143879, 0x05934F4F, 0x00D5893D, 0x0BD4BB0B, 0x15C92F6F,
	0x129C55F8, 0x125DD403, 0x1AD7BD57, 0x1A493E36, 0x079FF3F1, 0x022206B5,
	0x000FBA60, 0x17AE7581, 0x01F7C520, 0x0D72A3A2, 0x09FF6BC9, 0x0EF70570,
	0x0BD762CC, 0x0CFF187D, 0x0E5FB716, 0x19DA5870, 0x01CF2201, 0x1950E558,
	0x13466B09, 0x05C6B398, 0x081DFD49, 0x034209E9, 0x130B4C69, 0x1646F93E,
	0x0BA4843C, 0x1AA2FEC6, 0x02F4D488, 0x006BE82E, 0x1EB2294F, 0x08C3890B,
	0x09DC0754, 0x0D03A565, 0x13F91FFF, 0x16452A01, 0x1009BBB3, 0x0201144D,
	0x02DD2B6F, 0x19D56882, 0x1B5DD380, 0x13E00367, 0x010F164C, 0x17DB5AB1,
	0x0B76E035, 0x05A22CDA, 0x1D344768, 0x0B377E3D, 0x05156818, 0x0FDF676A,
	0x199098F3, 0x05F70981, 0x1FA6D835, 0x12BCFB3E, 0x16EA1DEA, 0x151D48C8,
	0x1D62837A, 0x1F9AEDC6, 0x1E73595C, 0x16105494, 0x0A9D6DE1, 0x08700AF0,
	0x1C3F124F, 0x1F9C1337, 0x0C058670, 0x17952D12, 0x0F289B94, 0x054A68DF,
	0x05386C72, 0x1F2BA6D3, 0x1BE0D1F3, 0x1F3563C4, 0x1E3FD68F, 0x00729D3F,
	0x1C41D8A9, 0x06E6F89A, 0x17A1656F, 0x1A3559C2, 0x06188E14, 0x09A52D77,
	0x0DB2B1BF, 0x1234B9F6, 0x106C9496, 0x17915D6A, 0x0A1BBEE9, 0x105713C8,
	0x0CFB9419, 0x06B16331, 0x0BCFF555, 0x1E21A51E, 0x08D4666E, 0x16C6E847,
	0x074F787D, 0x15395912, 0x0D56DD78, 0x1D07A3D7, 0x10122AA5, 0x1065DCF4,
	0x0F076702, 0x148BB174, 0x1595A7BF, 0x02BADE6B, 0x06D97B29, 0x06D2FBD9,
	0x007E1BC5, 0x161BB440, 0x1C4AC10C, 0x1EFDFA0C, 0x1A99ADA8, 0x1ADBC492,
	0x0780C3B6, 0x0A2FBEFA, 0x18D3BADA, 0x19C54686, 0x0C638627, 0x02264D8C,
	0x1B939B40, 0x0AB29F01, 0x07B8F391, 0x0486C2DF, 0x1A9A5EAE, 0x03E116F0,
	0x1DCC857B, 0x0A2C5151, 0x0A2BE171, 0x10F35006, 0x12936B6C, 0x010952D5,
	0x0F01582E, 0x1AF63BD5, 0x000B68FD, 0x15B0EC9C, 0x1DF12262, 0x1BDFFAE4,
	0x0169B949, 0x1B4FAB06, 0x0BB8FEFA, 0x07E84F52, 0x0C81356C, 0x14DFB4B9,
	0x03E92862, 0x0E2F4FFE, 0x1055CAF5, 0x07045A34, 0x0ECDE594, 0x10109B57,
	0x030DC0E1, 0x00986BA0, 0x1FBE71DE, 0x179D33AC, 0x101C5B7D, 0x1681D975,
	0x1ECB423F, 0x1C8CEE34, 0x1A5A2E8A, 0x058BB627, 0x15191338, 0x1DB8DC15,
	0x002F5B8B, 0x1D46C0AD, 0x053D9ABE, 0x1D312535, 0x1149F325, 0x1FB945C9,
	0x020A089F, 0x00E099A5, 0x1F57B8D0, 0x144C99A0, 0x11BCB376, 0x152A0710,
	0x16765BA1, 0x0A29B8C3, 0x05D2DC95, 0x020F83A1, 0x1C136448, 0x1759704C,
	0x1A722FAB, 0x08B633CB, 0x11AE8EEE, 0x150A8E82, 0x156FD871, 0x01351DDE,
	0x0349FE01, 0x06ABF56F, 0x1F8C5F13, 0x0B5C0AE6, 0x1301A5E1, 0x19CE87E6,
	0x123DE898, 0x15FA5982, 0x0786B6C2, 0x1FB682E1, 0x1CADFCE7, 0x0418CAA1,
	0x07FD64D2, 0x14C733E0, 0x022EC356, 0x0D18F7F9, 0x0D335619, 0x12473B7F,
	0x06C57118, 0x18522038, 0x06477130, 0x04A8A9BE, 0x11C10B3B, 0x1D874251,
	0x19271E6E, 0x08011F83, 0x0BB789D5, 0x10B4C5FB, 0x1EB98895, 0x05DF165F,
	0x1D6F09EA, 0x0F718016, 0x1E08A479, 0x166118F1, 0x03DC2FB6, 0x0E5DFD7E,
	0x1D5B14D0, 0x1C1635FA, 0x04C3AA37, 0x0E0E3595, 0x1FAFA951, 0x16ECACED,
	0x19DFFA18, 0x15D6E0D0, 0x00A8065D, 0x17615AF9, 0x1BC63FA7, 0x0DCBF00F,
	0x1D3D41C4, 0x09AE1D47, 0x13A1ABF4, 0x0DB7D402, 0x0E9C515B, 0x10B1D401,
	0x07DEC197, 0x1A27E5E4, 0x1AE04A8B, 0x1FC3FC76, 0x1F8E1EA1, 0x00DF44CB,
	0x1FB21DDC, 0x0B0C1420, 0x1DBF96B5, 0x0EFC1C20, 0x0D187332, 0x10050D67,
	0x0BBFB017, 0x07CA230A, 0x09EAEFBD, 0x091A916F, 0x0D530E05, 0x0239F90B,
	0x1BC0ED99, 0x0945BDF6, 0x1C533389, 0x14011A5C, 0x10669AF5, 0x1400DF83,
	0x015EFA53, 0x0703B1E8, 0x1B93B385, 0x06355982, 0x0F99D331, 0x181255F4,
	0x0D91623E, 0x151693BD, 0x1A3ECBE2, 0x1F41F424, 0x17BFD91E, 0x159FF455,
	0x1559E2B8, 0x19697B1D, 0x0B600E86, 0x194D249A, 0x0DE2F89F, 0x0E23A087,
	0x164FBE15, 0x1C6C6F4E, 0x0F919988, 0x0792A489, 0x1E0A35AD, 0x12A696A9,
	0x1DD16E46, 0x01FEDD2B, 0x13F740DB, 0x14129477, 0x02FDD05C, 0x1434BAF0,
	0x1DD14340, 0x12424E84, 0x15D3C223, 0x181B44B6, 0x0D71CEDA, 0x03E30848,
	0x1BD76873, 0x192BA473, 0x0C3EE722, 0x004D3AFB, 0x1CFA44BA, 0x0C6C7012,
	0x12F0072D, 0x12FAD860, 0x0AD261BA, 0x1066FA94, 0x09442F33, 0x15674A38,
	0x146A86B8, 0x16414ABC, 0x1033BE0E, 0x1750B6F3, 0x0A23841F, 0x0E400F7B,
	0x062C498D, 0x183C6270, 0x160CA68A, 0x137B6F0D, 0x08322295, 0x1C150963,
	0x0CC6B329, 0x0715A690, 0x196DAEFD, 0x138BB5BB, 0x03918CFC, 0x1E06E7C4,
	0x025C368A, 0x1D579E2B, 0x1559ECD1, 0x0B229847, 0x0BC5CA27, 0x1B0A3FE2,
	0x0538F009, 0x02F7A697, 0x04A51B67, 0x18B828DD, 0x0A2F38AB, 0x00191A20,
	0x1FBC9E7E, 0x0A433CF7, 0x053C8E18, 0x1768ADDE, 0x1393E3BF, 0x075AF4D9,
	0x02090000, 0x185D2DDA, 0x147BE6A1, 0x1E4210DE, 0x10861DD1, 0x02020BF6,
	0x096656AF, 0x15FB4063, 0x09368298, 0x09423DA0, 0x08841E49, 0x18CFA19B,
	0x115127FA, 0x0B5AB76F, 0x00062227, 0x0A948913, 0x0165C154, 0x05D9CDD3,
	0x17131420, 0x1E2B1920, 0x14FC53AC, 0x08E76C19, 0x11714787, 0x139236EF,
	0x03EC8B7E, 0x0D1DC35A, 0x0BA16EA0, 0x14F38C29, 0x081E1845, 0x009C8C9A,
	0x139D088D, 0x06085EFA, 0x189903C3, 0x0C593D9A, 0x0C36EA31, 0x00D87DE8,
	0x116B69DA, 0x1F0524B6, 0x0A3F67B4, 0x06559020, 0x1415BF89, 0x1FE87287,
	0x148BB150, 0x05FF5CEA, 0x0FBE7D24, 0x14EB4365, 0x18278AC3, 0x158F1542,
	0x06673297, 0x023F7E13, 0x01ED212F, 0x0DAEE736, 0x080EF4EC, 0x1299E004,
	0x16D2B588, 0x079BF79C, 0x1D6C57B5, 0x1EB00DE9, 0x19181C82, 0x00DB90C0,
	0x1777757F, 0x07A8345F, 0x004A34B0, 0x166CB5B2, 0x1DBAE8A4, 0x141608FE,
	0x1B3C0E25, 0x1DA65F20, 0x11EC946F, 0x0EE4B495, 0x1B139B0D, 0x17ABEBF2,
	0x102DB9DB, 0x0B3FE69B, 0x13851AB2, 0x0FC080AA, 0x029AE2B9, 0x1761DE47,
	0x1ACB0D2A, 0x02912FA9, 0x1EF007B3, 0x1CAC7A6E, 0x04F47954, 0x08C67ACF,
	0x0F5BA41B, 0x17E4717C, 0x1C328732, 0x1DFA5C73, 0x14979A05, 0x0B5B55A8,
	0x07CF521E, 0x11DEB870, 0x18FE00EC, 0x1126FF6C, 0x06C0895D, 0x0AB6C905,
	0x1192520D, 0x1E750FC6, 0x03C15FEF, 0x0D7D4A63, 0x16BF4CA0, 0x11E24869,
	0x12914429, 0x1A37B519, 0x1E6596BB, 0x0BC126C1, 0x000A0733, 0x0F62F242,
	0x1F2065E2, 0x18D56602, 0x00F205CF, 0x03C00D7F, 0x1449F07C, 0x0BDADD26,
	0x031DE11B, 0x0FB5598A, 0x1CCE037B, 0x01DB3CDA, 0x0FAAA0FC, 0x0A542E74,
	0x1C0CCBFB, 0x1CC79950, 0x0C5839D5, 0x0CF0EE46, 0x0A5DD9C7, 0x150867EA,
	0x183F19EA, 0x177E3116, 0x0F8E1731, 0x086D78A6, 0x1091A13F, 0x0CE570E3,
	0x1E9EBFE2, 0x05446DB3, 0x1DE77F03, 0x09277373, 0x00005186, 0x1776ECB1,
	0x1C05296E, 0x01669A18, 0x1317AF82, 0x1992A425, 0x146E7ECC, 0x155FA33F,
	0x0F1AF90D, 0x1C603DB5, 0x1706DB39, 0x17E5D7BB, 0x017680D7, 0x1078F821,
	0x0FFE8098, 0x07AECA92, 0x1FB745F2, 0x1A6B0D22, 0x12E084BF, 0x01AB7C19,
	0x17107C4F, 0x068A131D, 0x0704D46E, 0x0E6C1D68, 0x01A387AA, 0x12A7858A,
	0x0FEA9584, 0x051F4105, 0x1ECFF0C4, 0x1D14A6B3, 0x16728BCF, 0x11D7DA9B,
	0x1DD03EFD, 0x0F893F1C, 0x1AC2DDDC, 0x0A9B6736, 0x136E5268, 0x067EB67B,
	0x1E7F119A, 0x1BC329C9, 0x12113F8E, 0x16AF3109, 0x19E86F50, 0x1D2FC43C,
	0x05CA37BD, 0x073AD58B, 0x0320512F, 0x0B1AB343, 0x1963C782, 0x0360AF0F,
	0x1E8CAAFA, 0x140336A8, 0x069E7E90, 0x01346049, 0x1D6CC12C, 0x16B97A58,
	0x066C4DBC, 0x1081C8E2, 0x19DDFB80, 0x0BC24578, 0x1D928088, 0x0958C24D,
	0x1492BDAA, 0x061EFF4E, 0x1F70B8EF, 0x0FD98A30, 0x1678ACA2, 0x19D4E8AE,
	0x14B77C90, 0x1A588D5A, 0x18203EE8, 0x1CD793E9, 0x172D25F5, 0x00A77678,
	0x08E8DB80, 0x15447567, 0x1E63B93C, 0x0BEC2956, 0x1C2DAB61, 0x09ECDC67,
	0x0D8DF275, 0x0396FD06, 0x1EBCEA89, 0x04E411F4, 0x0A7AAF13, 0x0527CB67,
	0x0B5C262E, 0x1EE3FD08, 0x1265940A, 0x0DA7DCE0, 0x1C49D95C, 0x1142A376,
	0x059E9505, 0x1B679D9F, 0x0CF1E46B, 0x069A8999, 0x167465EA, 0x109E8BE7,
	0x0B64C389, 0x060A41A3, 0x1C3177EC, 0x1939F680, 0x090FDE61, 0x1463C6E5,
	0x10D5087C, 0x193D3F93, 0x0A23996A, 0x0D7C8338, 0x026AE576, 0x041F792A,
	0x006918D4, 0x09CD41CB, 0x112E236A, 0x1DC4DBE4, 0x1CA607A4, 0x1275ECE1,
	0x09635152, 0x0FF2F6B3, 0x0005B553, 0x06A4AA8A, 0x03EAEFEC, 0x1EF00581,
	0x0A73F9B5, 0x1EA5F77B, 0x0FC2EBFF, 0x0FFBEDCD, 0x0D12ED0E, 0x1678B073,
	0x05D9AD41, 0x14B962B4, 0x15086BEE, 0x082A4688, 0x00B61501, 0x11B35702,
	0x02E68C49, 0x114DDEEC, 0x1554DA45, 0x129EB99E, 0x1FD558B4, 0x06767D9F,
	0x12232C38, 0x098E6178, 0x1A19F755, 0x0FB35409, 0x1D50360B, 0x108B88C4,
	0x0EFB4107, 0x026755FB, 0x1D5E8568, 0x0537AA24, 0x10E1A30F, 0x0715DBAB,
	0x106A0595, 0x0DADC52B, 0x03DDF47B, 0x067D9A6A, 0x0481054A, 0x1D20D949,
	0x0380F94A, 0x01C8086A, 0x0DC285BE, 0x08F126B9, 0x1EC3221A, 0x05CDE357,
	0x01500D26, 0x0B82B7A0, 0x1327647A, 0x0FF5FCB7, 0x00B2B262, 0x09DE9555,
	0x0B1598AD, 0x11502120, 0x1C4E7AD3, 0x1011A294, 0x0B7BF6D1, 0x0F21DEC2,
	0x0A0B75A2, 0x1F8EF369, 0x1622F293, 0x19C3F93E, 0x1E3530AB, 0x1BDEE898,
	0x11B95062, 0x1C2E6A1C, 0x08864D34, 0x0F8A069A, 0x1B52A911, 0x072AF880,
	0x02C0CEF8, 0x14453973, 0x11FCE4FF, 0x0D765D28, 0x1DDDC7DE, 0x17B4A8BF,
	0x051A3FA5, 0x0E1B5351, 0x1E103355, 0x1680515A, 0x1B6C979A, 0x010263EB,
	0x0F4886F0, 0x0F1244EC, 0x03695837, 0x0120B2C0, 0x07036857, 0x19949043,
	0x11EB3D16, 0x1E5C4A4A, 0x074654F9, 0x014132A8, 0x1C93E1A9, 0x16B2E1A3,
	0x162FC864, 0x13823D26, 0x1CA65751, 0x03C46D3E, 0x1F2E5647, 0x0B199125,
	0x0BF1F69F, 0x10089F70, 0x18D1074A, 0x18784505, 0x1A72D0BC, 0x1FDC4639,
	0x0517B013, 0x0F88E04A, 0x0BCC51E8, 0x001F9E2A, 0x1FC38424, 0x03641E7F,
	0x02A8881C, 0x1C6C94EA, 0x19FF7D8A, 0x02F5581D
};


// -- Initialize built-in game offsets databases

// Black Ops 4 SP
std::array<DBGameInfo, 1> GameBlackOps4::SinglePlayerOffsets =
{{
	{ 0xA5FBC60, 0x0, 0x92895F0, 0x0 }
}};

// -- Finished with databases

// -- Begin XModelStream structures

struct GfxStreamVertex
{
	uint8_t Color[4];

	uint16_t UVUPosition;
	uint16_t UVVPosition;

	int32_t VertexNormal;
	int32_t VertexTangent;
};

struct GfxStreamWeight
{
	uint8_t WeightVal1;
	uint8_t WeightVal2;
	uint8_t WeightVal3;
	uint8_t WeightVal4;

	uint16_t WeightID1;
	uint16_t WeightID2;
	uint16_t WeightID3;
	uint16_t WeightID4;
};

struct GfxStreamFace
{
	uint16_t Index1;
	uint16_t Index2;
	uint16_t Index3;
};

// -- End XModelStream structures

// -- Black Ops 4 Pool Data Structure

struct BO4XAssetPoolData
{
	// The beginning of the pool
	uint64_t PoolPtr;

	// The size of the asset header
	uint32_t AssetSize;
	// The maximum pool size
	uint32_t PoolSize;

	// Padding
	uint32_t Padding;

	// The amount of assets in the pool
	uint32_t AssetsLoaded;

	// A pointer to the closest free header
	uint64_t PoolFreeHeadPtr;
};

// Verify that our pool data is exactly 0x20
static_assert(sizeof(BO4XAssetPoolData) == 0x20, "Invalid Pool Data Size (Expected 0x20)");

bool GameBlackOps4::LoadOffsets()
{
	// ----------------------------------------------------
	//	Black Ops 4 pools and sizes, XAssetPoolData is an array of pool info for each asset pool in the game
	//	The index of the assets we use are as follows: xanim (3), xmodel (4), ximage (0x9)
	//	Index * sizeof(BO4XAssetPoolData) = the offset of the asset info in this array of data, we can verify it using the xmodel pool and checking for the model hash (0x04647533e968c910)
	//  Notice: Black Ops 4 doesn't store a freePoolHandle at the beginning, so we just read on.
	//	On Black Ops 4, (0x04647533e968c910) will be the first xmodel
	//	Black Ops 4 stringtable, check entries, results may vary
	//	Reading is: (StringIndex * 16) + StringTablePtr + 16
	// ----------------------------------------------------

	// Attempt to load the game offsets
	if (CoDAssets::GameInstance != nullptr)
	{
		// We need the base address of the BO4 Module for ASLR + Heuristics
		auto BaseAddress = CoDAssets::GameInstance->GetMainModuleAddress();

		// Check built-in offsets via game exe mode (SP)
		for (auto& GameOffsets : SinglePlayerOffsets)
		{
			// Read required offsets (XANIM, XMODEL, XIMAGE, RAWFILE RELATED...)
			auto AnimPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(BaseAddress + GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 3));
			auto ModelPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(BaseAddress + GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 4));
			auto ImagePoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(BaseAddress + GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 0x9));

			// Apply game offset info
			CoDAssets::GameOffsetInfos.emplace_back(AnimPoolData.PoolPtr);
			CoDAssets::GameOffsetInfos.emplace_back(ModelPoolData.PoolPtr);
			CoDAssets::GameOffsetInfos.emplace_back(ImagePoolData.PoolPtr);

			// Verify via first xmodel asset, right now, we're using a hash
			auto FirstXModelHash = CoDAssets::GameInstance->Read<uint64_t>(CoDAssets::GameOffsetInfos[1]);
			// Check
			if (FirstXModelHash == 0x04647533e968c910)
			{
				// Verify string table, otherwise we are all set
				CoDAssets::GameOffsetInfos.emplace_back(BaseAddress + GameOffsets.StringTable);
				// Read and apply sizes
				CoDAssets::GamePoolSizes.emplace_back(AnimPoolData.PoolSize);
				CoDAssets::GamePoolSizes.emplace_back(ModelPoolData.PoolSize);
				CoDAssets::GamePoolSizes.emplace_back(ImagePoolData.PoolSize);
				// Return success
				return true;
			}
			// Reset
			CoDAssets::GameOffsetInfos.clear();
		}

		// Attempt to locate via heuristic searching
		auto DBAssetsScan = CoDAssets::GameInstance->Scan("48 89 5C 24 ?? 57 48 83 EC ?? 0F B6 F9 48 8D 05 ?? ?? ?? ??");
		auto StringTableScan = CoDAssets::GameInstance->Scan("48 8B 53 ?? 48 85 D2 74 ?? 48 8B 03 48 89 02");

		// Check that we had hits
		if (DBAssetsScan > 0 && StringTableScan > 0)
		{
			// Load info and verify
			auto GameOffsets = DBGameInfo(
				// Resolve pool info from LEA
				CoDAssets::GameInstance->Read<uint32_t>(DBAssetsScan + 0x10) + (DBAssetsScan + 0x14),
				// We don't use size offsets
				0,
				// Resolve strings from LEA
				CoDAssets::GameInstance->Read<uint32_t>(StringTableScan + 0x12) + (StringTableScan + 0x16),
				// We don't use package offsets
				0
			);

			// In debug, print the info for easy additions later!
#if _DEBUG
			// Format the output
			printf("Heuristic: { 0x%X, 0x0, 0x%X, 0x0 }\n", (GameOffsets.DBAssetPools - BaseAddress), (GameOffsets.StringTable - BaseAddress));
#endif


			// Read required offsets (XANIM, XMODEL, XIMAGE)
			auto AnimPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 3));
			auto ModelPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 4));
			auto ImagePoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 0x9));

			// Apply game offset info
			CoDAssets::GameOffsetInfos.emplace_back(AnimPoolData.PoolPtr);
			CoDAssets::GameOffsetInfos.emplace_back(ModelPoolData.PoolPtr);
			CoDAssets::GameOffsetInfos.emplace_back(ImagePoolData.PoolPtr);

			// Verify via first xmodel asset, right now, we're using a hash
			auto FirstXModelHash = CoDAssets::GameInstance->Read<uint64_t>(CoDAssets::GameOffsetInfos[1]);

			// Check
			if (FirstXModelHash == 0x04647533e968c910)
			{
				// Validate sizes
				if (
					AnimPoolData.AssetSize  == sizeof(BO4XAnim) && 
					ModelPoolData.AssetSize == sizeof(BO4XModel) && 
					ImagePoolData.AssetSize == sizeof(BO4GfxImage))
				{
					// Verify string table, otherwise we are all set
					CoDAssets::GameOffsetInfos.emplace_back(GameOffsets.StringTable);

					// Read and apply sizes
					CoDAssets::GamePoolSizes.emplace_back(AnimPoolData.PoolSize);
					CoDAssets::GamePoolSizes.emplace_back(ModelPoolData.PoolSize);
					CoDAssets::GamePoolSizes.emplace_back(ImagePoolData.PoolSize);

					// Return success
					return true;
				}
			}
		}
	}

	// Failed
	return false;
}

bool GameBlackOps4::LoadAssets()
{
	// Prepare to load game assets, into the AssetPool
	bool NeedsAnims = (SettingsManager::GetSetting("showxanim", "true") == "true");
	bool NeedsModels = (SettingsManager::GetSetting("showxmodel", "true") == "true");
	bool NeedsImages = (SettingsManager::GetSetting("showximage", "false") == "true");
	bool NeedsRawFiles = (SettingsManager::GetSetting("showxrawfiles", "false") == "true");

	/*
		This was implemented as a fix for a specific user who requested it, as the search box is capped at 32767 by Windows
		and this is a workaround, if you're interested in using it, any hashes in this filters file will be ignored on load,
		essentially acting as an excluder, consider it a hidden feature with no support as it was made for a specific use
		case. If you cannot get it to work, do not ask me.
	*/
	auto Filters = WraithNameIndex();
	Filters.LoadIndex("package_index\\bo4_filters.wni");

	// Check if we need assets
	if (NeedsAnims)
	{
		// Parse the XAnim pool
		CoDXPoolParser<uint64_t, BO4XAnim>((CoDAssets::GameOffsetInfos[0]), CoDAssets::GamePoolSizes[0], [Filters](BO4XAnim& Asset, uint64_t& AssetOffset)
		{
			// Mask the name as hashes are 60Bit
			Asset.NamePtr &= 0xFFFFFFFFFFFFFFF;

			// Check for filters
			if (Filters.NameDatabase.size() > 0)
			{
				// Check for this asset in DB
				if (Filters.NameDatabase.find(Asset.NamePtr) != Filters.NameDatabase.end())
				{
					// Skip this asset
					return;
				}
			}

			// Validate and load if need be
			auto AnimName = Strings::Format("xanim_%llx", Asset.NamePtr);

			// Check for an override in the name DB
			if (AssetNameCache.NameDatabase.find(Asset.NamePtr) != AssetNameCache.NameDatabase.end())
				AnimName = AssetNameCache.NameDatabase[Asset.NamePtr];

			// Make and add
			auto LoadedAnim = new CoDAnim_t();
			// Set
			LoadedAnim->AssetName = AnimName;
			LoadedAnim->AssetPointer = AssetOffset;
			LoadedAnim->Framerate = Asset.Framerate;
			LoadedAnim->FrameCount = Asset.NumFrames;
			LoadedAnim->AssetStatus = WraithAssetStatus::Loaded;
			// Add
			CoDAssets::GameAssets->LoadedAssets.push_back(LoadedAnim);
		});
	}

	if (NeedsModels)
	{
		// Parse the XModel pool
		CoDXPoolParser<uint64_t, BO4XModel>((CoDAssets::GameOffsetInfos[1]), CoDAssets::GamePoolSizes[1], [Filters](BO4XModel& Asset, uint64_t& AssetOffset)
		{
			// Mask the name as hashes are 60Bit
			Asset.NamePtr &= 0xFFFFFFFFFFFFFFF;

			// Check for filters
			if (Filters.NameDatabase.size() > 0)
			{
				// Check for this asset in DB
				if (Filters.NameDatabase.find(Asset.NamePtr) != Filters.NameDatabase.end())
				{
					// Skip this asset
					return;
				}
			}

			// Validate and load if need be
			auto ModelName = Strings::Format("xmodel_%llx", Asset.NamePtr);

			// Check for an override in the name DB
			if (AssetNameCache.NameDatabase.find(Asset.NamePtr) != AssetNameCache.NameDatabase.end())
				ModelName = AssetNameCache.NameDatabase[Asset.NamePtr];

			// Make and add
			auto LoadedModel = new CoDModel_t();
			// Set
			LoadedModel->AssetName = ModelName;
			LoadedModel->AssetPointer = AssetOffset;
			LoadedModel->BoneCount = (Asset.NumBones + Asset.NumCosmeticBones);
			LoadedModel->LodCount = Asset.NumLods;
			LoadedModel->AssetStatus = WraithAssetStatus::Loaded;
			// Add
			CoDAssets::GameAssets->LoadedAssets.push_back(LoadedModel);
		});
	}

	if (NeedsImages)
	{
		// Parse the XModel pool
		CoDXPoolParser<uint64_t, BO4GfxImage>((CoDAssets::GameOffsetInfos[2]), CoDAssets::GamePoolSizes[2], [Filters](BO4GfxImage& Asset, uint64_t& AssetOffset)
		{
			// Mask the name as hashes are 60Bit
			Asset.NamePtr &= 0xFFFFFFFFFFFFFFF;

			// Check for filters
			if (Filters.NameDatabase.size() > 0)
			{
				// Check for this asset in DB
				if (Filters.NameDatabase.find(Asset.NamePtr) != Filters.NameDatabase.end())
				{
					// Skip this asset
					return;
				}
			}

			// Validate and load if need be
			auto ImageName = Strings::Format("ximage_%llx", Asset.NamePtr);

			// Check for an override in the name DB
			if (AssetNameCache.NameDatabase.find(Asset.NamePtr) != AssetNameCache.NameDatabase.end())
				ImageName = AssetNameCache.NameDatabase[Asset.NamePtr];

			// Check for loaded images
			// if (Asset.GfxMipsPtr != 0)
			{
				// Make and add
				auto LoadedImage = new CoDImage_t();
				// Set
				LoadedImage->AssetName = ImageName;
				LoadedImage->AssetPointer = AssetOffset;
				LoadedImage->Width = (uint16_t)Asset.LoadedMipWidth;
				LoadedImage->Height = (uint16_t)Asset.LoadedMipHeight;
				LoadedImage->Format = (uint16_t)Asset.ImageFormat;
				LoadedImage->AssetStatus = WraithAssetStatus::Loaded;
				// Add
				CoDAssets::GameAssets->LoadedAssets.push_back(LoadedImage);
			}
		});
	}

	// Success, error only on specific load
	return true;
}

std::unique_ptr<XAnim_t> GameBlackOps4::ReadXAnim(const CoDAnim_t* Animation)
{
	// Verify that the program is running
	if (CoDAssets::GameInstance->IsRunning())
	{
		// Prepare to read the xanim
		auto Anim = std::make_unique<XAnim_t>();

		// Read the XAnim structure
		auto AnimData = CoDAssets::GameInstance->Read<BO4XAnim>(Animation->AssetPointer);

		// Copy over default properties
		Anim->AnimationName = Animation->AssetName;
		// Frames and Rate
		Anim->FrameCount = AnimData.NumFrames;
		Anim->FrameRate = AnimData.Framerate;

		// Check for viewmodel animations
		if ((_strnicmp(Animation->AssetName.c_str(), "viewmodel_", 10) == 0) || (_strnicmp(Animation->AssetName.c_str(), "vm_", 3) == 0))
		{
			// This is a viewmodel animation
			Anim->ViewModelAnimation = true;
		}
		////// Check for additive animations
		////if (AnimData.AssetType == 0x6)
		////{
		////	// This is a additive animation
		////	Anim->AdditiveAnimation = true;
		////}
		////// Check for looping
		////Anim->LoopingAnimation = (AnimData.LoopingFlag > 0);

		// Read the delta data
		auto AnimDeltaData = CoDAssets::GameInstance->Read<BO4XAnimDeltaParts>(AnimData.DeltaPartsPtr);

		// Copy over pointers
		Anim->BoneIDsPtr = AnimData.BoneIDsPtr;
		Anim->DataBytesPtr = AnimData.DataBytePtr;
		Anim->DataShortsPtr = AnimData.DataShortPtr;
		Anim->DataIntsPtr = AnimData.DataIntPtr;
		Anim->RandomDataBytesPtr = AnimData.RandomDataBytePtr;
		Anim->RandomDataShortsPtr = AnimData.RandomDataShortPtr;
		Anim->NotificationsPtr = AnimData.NotificationsPtr;

		// Bone ID index size
		Anim->BoneIndexSize = 4;

		// Copy over counts
		Anim->NoneRotatedBoneCount = AnimData.NoneRotatedBoneCount;
		Anim->TwoDRotatedBoneCount = AnimData.TwoDRotatedBoneCount;
		Anim->NormalRotatedBoneCount = AnimData.NormalRotatedBoneCount;
		Anim->TwoDStaticRotatedBoneCount = AnimData.TwoDStaticRotatedBoneCount;
		Anim->NormalStaticRotatedBoneCount = AnimData.NormalStaticRotatedBoneCount;
		Anim->NormalTranslatedBoneCount = AnimData.NormalTranslatedBoneCount;
		Anim->PreciseTranslatedBoneCount = AnimData.PreciseTranslatedBoneCount;
		Anim->StaticTranslatedBoneCount = AnimData.StaticTranslatedBoneCount;
		Anim->NoneTranslatedBoneCount = AnimData.NoneTranslatedBoneCount;
		Anim->TotalBoneCount = AnimData.TotalBoneCount;
		Anim->NotificationCount = AnimData.NotificationCount;

		// Copy delta
		Anim->DeltaTranslationPtr = AnimDeltaData.DeltaTranslationsPtr;
		Anim->Delta2DRotationsPtr = AnimDeltaData.Delta2DRotationsPtr;
		Anim->Delta3DRotationsPtr = AnimDeltaData.Delta3DRotationsPtr;

		// Set types, we use quata for BO4
		Anim->RotationType = AnimationKeyTypes::QuatPackingA;
		Anim->TranslationType = AnimationKeyTypes::MinSizeTable;

		// Black Ops 4 doesn't support inline indicies
		Anim->SupportsInlineIndicies = false;

		// Return it
		return Anim;
	}
	// Not running
	return nullptr;
}

std::unique_ptr<XModel_t> GameBlackOps4::ReadXModel(const CoDModel_t* Model)
{
	// Verify that the program is running
	if (CoDAssets::GameInstance->IsRunning())
	{
		// Read the XModel structure
		auto ModelData = CoDAssets::GameInstance->Read<BO4XModel>(Model->AssetPointer);

		// Prepare to read the xmodel (Reserving space for lods)
		auto ModelAsset = std::make_unique<XModel_t>(ModelData.NumLods);

		// Copy over default properties
		ModelAsset->ModelName = Model->AssetName;
		// Bone counts
		ModelAsset->BoneCount = ModelData.NumBones;
		ModelAsset->RootBoneCount = ModelData.NumRootBones;
		ModelAsset->CosmeticBoneCount = ModelData.NumCosmeticBones;

		// Bone data type
		ModelAsset->BoneRotationData = BoneDataTypes::QuatPackingA;

		// We are streamed
		ModelAsset->IsModelStreamed = true;

		// Bone id info
		ModelAsset->BoneIDsPtr = ModelData.BoneIDsPtr;
		ModelAsset->BoneIndexSize = 4;

		// Bone parent info
		ModelAsset->BoneParentsPtr = ModelData.ParentListPtr;
		ModelAsset->BoneParentSize = 1;

		// Local bone pointers
		ModelAsset->RotationsPtr = ModelData.RotationsPtr;
		ModelAsset->TranslationsPtr = ModelData.TranslationsPtr;

		// Global matricies
		ModelAsset->BaseMatriciesPtr = ModelData.BaseMatriciesPtr;

		// Prepare to parse lods
		for (uint32_t i = 0; i < ModelData.NumLods; i++)
		{
			// Read the lod
			auto LODInfo = CoDAssets::GameInstance->Read<BO4XModelLod>(ModelData.ModelLodPtrs[i]);
			// Create the lod and grab reference
			ModelAsset->ModelLods.emplace_back(LODInfo.NumSurfs);
			// Grab reference
			auto& LodReference = ModelAsset->ModelLods[i];

			// Set distance
			LodReference.LodDistance = LODInfo.LodDistance;

			// Set stream key and info ptr
			LodReference.LODStreamKey = LODInfo.LODStreamKey;
			LodReference.LODStreamInfoPtr = LODInfo.XModelMeshPtr;

			// Grab pointer from the lod itself
			auto XSurfacePtr = LODInfo.XSurfacePtr;

			// Skip 8 bytes in materials
			ModelData.MaterialHandlesPtr += 8;
			// Read material handles ptr
			auto MaterialHandlesPtr = CoDAssets::GameInstance->Read<uint64_t>(ModelData.MaterialHandlesPtr);
			// Advance 8 and skip 16 bytes
			ModelData.MaterialHandlesPtr += 0x10;

			// Load surfaces
			for (uint32_t s = 0; s < LODInfo.NumSurfs; s++)
			{
				// Create the surface and grab reference
				LodReference.Submeshes.emplace_back();
				// Grab reference
				auto& SubmeshReference = LodReference.Submeshes[s];

				// Read the surface data
				auto SurfaceInfo = CoDAssets::GameInstance->Read<BO4XModelSurface>(XSurfacePtr);

				// Apply surface info
				SubmeshReference.VertexCount = SurfaceInfo.VertexCount;
				SubmeshReference.FaceCount = SurfaceInfo.FacesCount;
				SubmeshReference.VertexPtr = SurfaceInfo.VerticiesIndex;
				SubmeshReference.FacesPtr = SurfaceInfo.FacesIndex;

				// Assign weight info to the count slots, to save memory
				SubmeshReference.WeightCounts[0] = SurfaceInfo.Flag1;
				SubmeshReference.WeightCounts[1] = SurfaceInfo.Flag2;
				SubmeshReference.WeightCounts[2] = SurfaceInfo.Flag3;
				SubmeshReference.WeightCounts[3] = SurfaceInfo.Flag4;

				// Read this submesh's material handle
				auto MaterialHandle = CoDAssets::GameInstance->Read<uint64_t>(MaterialHandlesPtr);
				// Create the material and add it
				LodReference.Materials.emplace_back(ReadXMaterial(MaterialHandle));

				// Advance
				XSurfacePtr += sizeof(BO4XModelSurface);
				MaterialHandlesPtr += sizeof(uint64_t);
			}
		}

		// Return it
		return ModelAsset;
	}
	// Not running
	return nullptr;
}

std::unique_ptr<XImageDDS> GameBlackOps4::ReadXImage(const CoDImage_t* Image)
{
	// Proxy off
	return LoadXImage(XImage_t(ImageUsageType::DiffuseMap, 0, Image->AssetPointer, Image->AssetName));
}

const XMaterial_t GameBlackOps4::ReadXMaterial(uint64_t MaterialPointer)
{
	// Prepare to parse the material
	auto MaterialData = CoDAssets::GameInstance->Read<BO4XMaterial>(MaterialPointer);

	// Mask the name (some bits are used for other stuffs)
	MaterialData.Hash &= 0xFFFFFFFFFFFFFFF;
	// Allocate a new material with the given image count
	XMaterial_t Result(MaterialData.ImageCount);
	// Clean the name, then apply it
	Result.MaterialName = Strings::Format("xmaterial_%llx", MaterialData.Hash);

	// Check for an override in the name DB
	if (AssetNameCache.NameDatabase.find(MaterialData.Hash) != AssetNameCache.NameDatabase.end())
		Result.MaterialName = AssetNameCache.NameDatabase[MaterialData.Hash];

	// Iterate over material images, assign proper references if available
	for (uint32_t m = 0; m < MaterialData.ImageCount; m++)
	{
		// Read the image info
		auto ImageInfo = CoDAssets::GameInstance->Read<BO4XMaterialImage>(MaterialData.ImageTablePtr);

		// Get Hash and mask it (some bits are used for other stuffs)
		auto ImageHash = CoDAssets::GameInstance->Read<uint64_t>(ImageInfo.ImagePtr + 0x20) & 0xFFFFFFFFFFFFFFF;

		// Get the image name
		auto ImageName = Strings::Format("ximage_%llx", ImageHash);

		// Check for an override in the name DB
		if (AssetNameCache.NameDatabase.find(ImageHash) != AssetNameCache.NameDatabase.end())
			ImageName = AssetNameCache.NameDatabase[ImageHash];

		// Default type
		auto DefaultUsage = ImageUsageType::Unknown;
		// Check 
		switch (ImageInfo.SemanticHash)
		{
		case 0xA0AB1041:
			DefaultUsage = ImageUsageType::DiffuseMap;
			break;
		case 0x59D30D0F:
			DefaultUsage = ImageUsageType::NormalMap;
			break;
		case 0xEC443804:
			DefaultUsage = ImageUsageType::SpecularMap;
			break;
		}

		// Assign the new image
		Result.Images.emplace_back(DefaultUsage, ImageInfo.SemanticHash, ImageInfo.ImagePtr, ImageName);

		// Advance
		MaterialData.ImageTablePtr += sizeof(BO4XMaterialImage);
	}

	// Return it
	return Result;
}

std::unique_ptr<XImageDDS> GameBlackOps4::LoadXImage(const XImage_t& Image)
{
	// Prepare to load an image, we need to rip loaded and streamed ones
	uint32_t ResultSize = 0;

	// We must read the image data
	auto ImageInfo = CoDAssets::GameInstance->Read<BO4GfxImage>(Image.ImagePtr);

	// Calculate the largest image mip
	uint32_t LargestMip = 0;
	uint32_t LargestWidth = 0;
	uint32_t LargestHeight = 0;
	uint64_t LargestHash = 0;

	// Loop and calculate
	for (uint32_t i = 0; i < ImageInfo.GfxMipMaps; i++)
	{
		// Load Mip Map
		auto MipMap = CoDAssets::GameInstance->Read<BO4GfxMip>(ImageInfo.GfxMipsPtr);
		// Compare widths
		if (MipMap.Width > LargestWidth)
		{
			LargestMip = i;
			LargestWidth = MipMap.Width;
			LargestHeight = MipMap.Height;
			LargestHash = MipMap.HashID;
		}
		// Advance Mip Map Pointer
		ImageInfo.GfxMipsPtr += sizeof(BO4GfxMip);
	}

	// Calculate proper image format (Convert signed to unsigned)
	switch (ImageInfo.ImageFormat)
	{
		// Fix invalid BC1_SRGB images, swap to BC1_UNORM
	case 72: ImageInfo.ImageFormat = 71; break;
		// Fix invalid BC2_SRGB images, swap to BC2_UNORM
	case 75: ImageInfo.ImageFormat = 74; break;
		// Fix invalid BC3_SRGB images, swap to BC3_UNORM
	case 78: ImageInfo.ImageFormat = 77; break;
		// Fix invalid BC7_SRGB images, swap to BC7_UNORM
	case 99: ImageInfo.ImageFormat = 98; break;
	}

	// Buffer
	std::unique_ptr<uint8_t[]> ImageData = nullptr;

	// Check if we're missing a hash / size
	if (LargestWidth == 0 || LargestHash == 0)
	{
		// Set sizes
		LargestWidth = ImageInfo.LoadedMipWidth;
		LargestHeight = ImageInfo.LoadedMipHeight;

		// Temporary size
		uintptr_t ImageMemoryResult = 0;
		// We have a loaded image, prepare to dump from memory
		auto ImageMemoryBuffer = CoDAssets::GameInstance->Read(ImageInfo.LoadedMipPtr, ImageInfo.LoadedMipSize, ImageMemoryResult);

		// Make sure we got it
		if (ImageMemoryBuffer != nullptr)
		{
			// Allocate a safe block
			ImageData = std::make_unique<uint8_t[]>((uint32_t)ImageMemoryResult);
			// Copy data over
			std::memcpy(ImageData.get(), ImageMemoryBuffer, ImageMemoryResult);

			// Set size
			ResultSize = (uint32_t)ImageMemoryResult;

			// Clean up
			delete[] ImageMemoryBuffer;
		}
	}
	else
	{
		// We have a streamed image, prepare to extract
		ImageData = CoDAssets::GamePackageCache->ExtractPackageObject(LargestHash, ResultSize);
	}

	// Prepare if we have it
	if (ImageData != nullptr)
	{
		// Prepare to create a MemoryDDS file
		auto Result = CoDRawImageTranslator::TranslateBC(ImageData, ResultSize, LargestWidth, LargestHeight, ImageInfo.ImageFormat);

		// Check for, and apply patch if required, if we got a raw result
		if (Result != nullptr && Image.ImageUsage == ImageUsageType::NormalMap && (SettingsManager::GetSetting("patchnormals", "true") == "true"))
		{
			// Set normal map patch
			Result->ImagePatchType = ImagePatch::Normal_Expand;
		}

		// Return it
		return Result;
	}

	// Failed to load the image
	return nullptr;
}

void GameBlackOps4::LoadXModel(const XModelLod_t& ModelLOD, const std::unique_ptr<WraithModel>& ResultModel)
{
	// Check if we want Vertex Colors
	bool ExportColors = (SettingsManager::GetSetting("exportvtxcolor", "true") == "true");
	// Read the mesh information
	auto MeshInfo = CoDAssets::GameInstance->Read<BO4XModelMeshInfo>(ModelLOD.LODStreamInfoPtr);

	// A buffer for the mesh data
	std::unique_ptr<uint8_t[]> MeshDataBuffer = nullptr;
	// Resulting size
	uint64_t MeshDataBufferSize = 0;

	// Vertex has extended vertex information
	bool HasExtendedVertexInfo = (MeshInfo.StatusFlag & 64) != 0;

	// Determine if we need to load the mesh or not (Seems flag == 8 is loaded)
	if ((MeshInfo.StatusFlag & 0x3F) == 8)
	{
		// Result size
		uintptr_t ResultSize = 0;
		// The mesh is already loaded, just read it
		auto TemporaryBuffer = CoDAssets::GameInstance->Read(MeshInfo.XModelMeshBufferPtr, MeshInfo.XModelMeshBufferSize, ResultSize);

		// Copy and clean up
		if (TemporaryBuffer != nullptr)
		{
			// Allocate safe
			MeshDataBuffer = std::make_unique<uint8_t[]>(MeshInfo.XModelMeshBufferSize);
			// Copy over
			std::memcpy(MeshDataBuffer.get(), TemporaryBuffer, (size_t)ResultSize);
			// Set size
			MeshDataBufferSize = ResultSize;

			// Clean up
			delete[] TemporaryBuffer;
		}
	}
	else
	{
		// Result size
		uint32_t ResultSize = 0;
		// We must read from the cache
		MeshDataBuffer = CoDAssets::GamePackageCache->ExtractPackageObject(ModelLOD.LODStreamKey, ResultSize);
		// Set size
		MeshDataBufferSize = ResultSize;
	}

	// Continue on success
	if (MeshDataBuffer != nullptr)
	{
		// Make a reader to begin reading the mesh (Don't close)
		auto MeshReader = MemoryReader((int8_t*)MeshDataBuffer.get(), MeshDataBufferSize, true);

		// The total weighted verticies
		uint32_t TotalReadWeights = 0;
		// The maximum weight index
		uint32_t MaximumWeightIndex = ResultModel->BoneCount() - 1;

		// Prepare it for submeshes
		ResultModel->PrepareSubmeshes((uint32_t)ModelLOD.Submeshes.size());

		// Iterate over submeshes
		for (auto& Submesh : ModelLOD.Submeshes)
		{
			// Create and grab a new submesh
			auto& Mesh = ResultModel->AddSubmesh();

			// Set the material (COD has 1 per submesh)
			Mesh.AddMaterial(Submesh.MaterialIndex);

			// Prepare the mesh for the data
			Mesh.PrepareMesh(Submesh.VertexCount, Submesh.FaceCount);

			// Jump to vertex position data, advance to this submeshes verticies
			MeshReader.SetPosition(MeshInfo.VertexOffset + (Submesh.VertexPtr * 12));

			// Iterate over verticies
			for (uint32_t i = 0; i < Submesh.VertexCount; i++)
			{
				// Make a new vertex
				auto& Vertex = Mesh.AddVertex();

				// Read and assign position
				Vertex.Position = MeshReader.Read<Vector3>();
			}

			// Jump to vertex info data, advance to this submeshes info, seek further for extended vertex info
			MeshReader.SetPosition(MeshInfo.UVOffset + (Submesh.VertexPtr * (HasExtendedVertexInfo ? 24 : 16)));

			// Iterate over verticies
			for (uint32_t i = 0; i < Submesh.VertexCount; i++)
			{
				// Grab the reference
				auto& Vertex = Mesh.Verticies[i];

				// Read vertex data
				auto VertexData = MeshReader.Read<GfxStreamVertex>();

				// Add UV layer
				Vertex.AddUVLayer(HalfFloats::ToFloat(VertexData.UVUPosition), HalfFloats::ToFloat(VertexData.UVVPosition));

				// Unpack normal
				int32_t PackedX = (((VertexData.VertexNormal >> 0) & ((1 << 10) - 1)) - 512);
				int32_t PackedY = (((VertexData.VertexNormal >> 10) & ((1 << 10) - 1)) - 512);
				int32_t PackedZ = (((VertexData.VertexNormal >> 20) & ((1 << 10) - 1)) - 512);
				// Calculate
				Vertex.Normal.X = ((float)PackedX / 511.0f);
				Vertex.Normal.Y = ((float)PackedY / 511.0f);
				Vertex.Normal.Z = ((float)PackedZ / 511.0f);

				// Add Colors if we want them
				if (ExportColors)
				{
					Vertex.Color[0] = VertexData.Color[0];
					Vertex.Color[1] = VertexData.Color[1];
					Vertex.Color[2] = VertexData.Color[2];
					Vertex.Color[3] = VertexData.Color[3];
				}
				else
				{
					Vertex.Color[0] = 0xFF;
					Vertex.Color[1] = 0xFF;
					Vertex.Color[2] = 0xFF;
					Vertex.Color[3] = 0xFF;
				}

				// Skip extended vertex information (first 4 bytes seems to be UV, possibly for better camo UV Mapping)
				if (HasExtendedVertexInfo)
					MeshReader.Advance(8);
			}

			// Jump to vertex weight data, advance to this submeshes info
			MeshReader.SetPosition(MeshInfo.WeightsOffset + (Submesh.VertexPtr * 12));

			// Iterate over verticies
			for (uint32_t i = 0; i < Submesh.VertexCount; i++)
			{
				// Grab the reference
				auto& Vertex = Mesh.Verticies[i];
				
				// Check if we're a complex weight, up to four weights
				if (((uint8_t)Submesh.WeightCounts[0] & 2) > 0)
				{
					// Read weight data
					auto VertexWeight = MeshReader.Read<GfxStreamWeight>();

					// Add if need be
					Vertex.AddVertexWeight(VertexWeight.WeightID1, (VertexWeight.WeightVal1 / 255.0f));
					// Calculate max
					MaximumWeightIndex = std::max<uint32_t>(VertexWeight.WeightID1, MaximumWeightIndex);

					// Check for value 2
					if (VertexWeight.WeightVal2 > 0)
					{
						Vertex.AddVertexWeight(VertexWeight.WeightID2, (VertexWeight.WeightVal2 / 255.0f));
						// Calculate max
						MaximumWeightIndex = std::max<uint32_t>(VertexWeight.WeightID2, MaximumWeightIndex);
					}

					// Check for value 3
					if (VertexWeight.WeightVal3 > 0)
					{
						Vertex.AddVertexWeight(VertexWeight.WeightID3, (VertexWeight.WeightVal3 / 255.0f));
						// Calculate max
						MaximumWeightIndex = std::max<uint32_t>(VertexWeight.WeightID3, MaximumWeightIndex);
					}

					// Check for value 4
					if (VertexWeight.WeightVal4 > 0)
					{
						Vertex.AddVertexWeight(VertexWeight.WeightID4, (VertexWeight.WeightVal4 / 255.0f));
						// Calculate max
						MaximumWeightIndex = std::max<uint32_t>(VertexWeight.WeightID4, MaximumWeightIndex);
					}

					// Increase
					TotalReadWeights++;
				}
				else
				{
					// Simple weight
					Vertex.AddVertexWeight(0, 1.0);
				}

			}

			// Jump to face data, advance to this submeshes faces
			MeshReader.SetPosition(MeshInfo.FacesOffset + (Submesh.FacesPtr * 2));

			// Iterate over faces
			for (uint32_t i = 0; i < Submesh.FaceCount; i++)
			{
				// Read data
				auto Face = MeshReader.Read<GfxStreamFace>();

				// Add the face
				Mesh.AddFace(Face.Index1, Face.Index2, Face.Index3);
			}
		}

		// Prepare to generate stream bones if we had a conflict
		if (MaximumWeightIndex > (ResultModel->BoneCount() - 1))
		{
			// Generate stream bones
			auto CurrentBoneCount = ResultModel->BoneCount();
			auto WantedBoneCount = (MaximumWeightIndex + 1);

			// Loop and create
			for (uint32_t i = 0; i < (WantedBoneCount - CurrentBoneCount); i++)
			{
				auto& StreamBone = ResultModel->AddBone();

				// Set name and parent
				StreamBone.TagName = Strings::Format("smod_bone%d", i);
				StreamBone.BoneParent = 0;
			}

			// Ensure root is tag_origin
			ResultModel->Bones[0].TagName = "tag_origin";
		}
	}
}

std::string GameBlackOps4::DecryptString(uint8_t* InputBuffer, uint8_t InputLength, uint8_t EncryptionID, uint64_t StringHash)
{
	//if ((*a1 & 0xC0) != -128)
	//	return v14;
	uint8_t  x = EncryptionID + 128;
	switch ((uint8_t)(EncryptionID + 128))
	{
	case 1:
	{
		// Start values
		uint32_t k = -10;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k += i;
			// Edit key
			j = -10 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 4:
	{
		// Start values
		uint32_t k = 117;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = 117 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 5:
	{
		// Start values
		uint32_t k = -10;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Edit key
			j = k - 10;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 7:
	{
		// Start values
		uint32_t k = -114;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Edit key
			j = k ^ 142;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 8:
	{
		// Start values
		uint32_t k = 76;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = 76 + k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 10:
	{
		// Start values
		uint32_t k = 943;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k += DecryptionTable[(uint8_t)k + ((i & 0xF) << 8)];
			// Edit key
			j = -81 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 11:
	{
		// Start values
		uint32_t k = 83;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = 83 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 12:
	{
		// Start values
		uint32_t k = -9;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = -9 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 13:
	{
		// Start values
		uint32_t k = 117;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = 117 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 15:
	{
		// Start values
		uint32_t k = 104;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k ^ 104;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 17:
	{
		// Start values
		uint32_t k = 81;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k += i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = 81 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 18:
	{
		// Start values
		uint32_t k = 978;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k ^= DecryptionTable[(uint8_t)k + ((k & 0xF) << 8)];
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k - 46;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 21:
	{
		// Start values
		uint32_t k = 975;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k -= DecryptionTable[(uint8_t)k + ((i & 0xF) << 8)];
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = -49 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 22:
	{
		// Start values
		uint32_t k = 36;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k ^ 36;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 24:
	{
		// Start values
		uint32_t k = 4;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k + 4;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 25:
	{
		// Start values
		uint32_t k = 124;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = 124 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 26:
	{
		// Start values
		uint32_t k = 479;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k *= DecryptionTable[i + ((k & 0xF) << 8)];
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = -33 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 28:
	{
		// Start values
		uint32_t k = 82;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k ^ 82;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 29:
	{
		// Start values
		uint32_t k = -31;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k ^ 225;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 30:
	{
		// Start values
		uint32_t k = -124;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = -124 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 31:
	{
		// Start values
		uint32_t k = 30;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k += i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k ^ 30;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 33:
	{
		// Start values
		uint32_t k = -128;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = -128 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 34:
	{
		// Start values
		uint32_t k = 660;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k -= DecryptionTable[i + ((i & 0xF) << 8)];
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = -108 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 36:
	{
		// Start values
		uint32_t k = 18;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k += i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = 18 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 37:
	{
		// Start values
		uint32_t k = -110;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k += i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = -110 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 38:
	{
		// Start values
		uint32_t k = 111;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k *= DecryptionTable[(uint8_t)k + ((k & 0xF) << 8)];
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = 111 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 39:
	{
		// Start values
		uint32_t k = 55;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = 55 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 41:
	{
		// Start values
		uint32_t k = 25;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k += i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k + 25;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 42:
	{
		// Start values
		uint32_t k = -67;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Edit key
			j = -67 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 43:
	{
		// Start values
		uint32_t k = 22;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Edit key
			j = 22 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 44:
	{
		// Start values
		uint32_t k = -26;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Edit key
			j = k ^ 230;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 47:
	{
		// Start values
		uint32_t k = 47;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Edit key
			j = 47 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 50:
	{
		// Start values
		uint32_t k = 22;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k ^ 22;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 51:
	{
		// Start values
		uint32_t k = 15;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k ^ 15;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 53:
	{
		// Start values
		uint32_t k = 538;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k += DecryptionTable[i + ((k & 0xF) << 8)];
			// Edit key
			j = 26 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 54:
	{
		// Start values
		uint32_t k = 14;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Edit key
			j = 14 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 56:
	{
		// Start values
		uint32_t k = 1;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Edit key
			j = k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 57:
	{
		// Start values
		uint32_t k = 96;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k ^ 96;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 59:
	{
		// Start values
		uint32_t k = 82;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Edit key
			j = 82 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 61:
	{
		// Start values
		uint32_t k = 682;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k -= DecryptionTable[(uint8_t)k + ((i & 0xF) << 8)];
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = -86 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 63:
	{
		// Start values
		uint32_t k = 71;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k ^= DecryptionTable[(uint8_t)k + ((i & 0xF) << 8)];
			// Edit key
			j = k + 71;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	default:
		break;
	}
#if _DEBUG
	// Validate strings in debug to check for encryption changes
	uint64_t Hash = 0xCBF29CE484222325;
	// Loop through string
	for (uint8_t i = 0; i < InputLength; i++)
		Hash = 0x100000001B3 * (InputBuffer[i] ^ Hash);
	// Check it against input
	if (Hash != StringHash)
		printf("Hash check failed: ID %#X - Input Hash 0x%llX - Hash Result 0x%llX - %s - Size %i\n", EncryptionID, StringHash, Hash, InputBuffer, InputLength);
#endif
	// Done
	return std::string(reinterpret_cast<char const*>(InputBuffer), InputLength - 1);
}

std::string GameBlackOps4::LoadStringEntry(uint64_t Index)
{
	// Calculate Offset to String (Offsets[3] = StringTable)
	auto Offset = CoDAssets::GameOffsetInfos[3] + (Index * 20);
	// Read Result
	uint64_t BytesRead = 0;
	// Read Info
	auto StringHash      = CoDAssets::GameInstance->Read<uint64_t>(Offset + 8);
	auto EncryptionID    = CoDAssets::GameInstance->Read<uint8_t>(Offset + 16);
	auto StringSize      = CoDAssets::GameInstance->Read<uint8_t>(Offset + 17);
	// Check 0 length
	if (StringSize == 0)
		return "";
	auto EncryptedString = (uint8_t*)CoDAssets::GameInstance->Read(Offset + 18, StringSize, BytesRead);
	// Pass to decryptor
	auto Result = DecryptString(EncryptedString, StringSize, EncryptionID, StringHash);
	// Clean up
	delete[] EncryptedString;
	// Done
	return Result;
}
void GameBlackOps4::PerformInitialSetup()
{
	// Load Caches
	AssetNameCache.LoadIndex(FileSystems::CombinePath(FileSystems::GetApplicationPath(), "package_index\\bo4_xanim.wni"));
	AssetNameCache.LoadIndex(FileSystems::CombinePath(FileSystems::GetApplicationPath(), "package_index\\bo4_ximage.wni"));
	AssetNameCache.LoadIndex(FileSystems::CombinePath(FileSystems::GetApplicationPath(), "package_index\\bo4_xmaterial.wni"));
	AssetNameCache.LoadIndex(FileSystems::CombinePath(FileSystems::GetApplicationPath(), "package_index\\bo4_xmodel.wni"));

	// Prepare to copy the oodle dll
	auto OurPath = FileSystems::CombinePath(FileSystems::GetApplicationPath(), "oo2core_6_win64.dll");

	// Copy if not exists
	if (!FileSystems::FileExists(OurPath))
		FileSystems::CopyFile(FileSystems::CombinePath(FileSystems::GetDirectoryName(CoDAssets::GameInstance->GetProcessPath()), "oo2core_6_win64.dll"), OurPath);
}