#include "stdafx.h"

// The class we are implementing
#include "GameBlackOps4.h"

// We need the CoDAssets class
#include "CoDAssets.h"
#include "CoDRawImageTranslator.h"
#include "CoDXPoolParser.h"

// We need the following WraithX classes
#include "Strings.h"
#include "FileSystems.h"
#include "MemoryReader.h"
#include "SettingsManager.h"
#include "HalfFloats.h"

// -- Initialize Asset Name Cache

WraithNameIndex GameBlackOps4::AssetNameCache = WraithNameIndex();

// -- Initialize Decryption Table

uint32_t* DecryptionTable = new uint32_t[0x1000]
{
	0x3A37FEB8, 0x2E725A9E, 0x19C49164, 0x187D0134, 0x16C33AA9, 0x0EAC0E70, 0x1FD416C7, 0x022ACA3A,
	0x38E47988, 0x1507CC8E, 0x0C4A2A59, 0x08D19B45, 0x34E3E1F7, 0x3B858806, 0x2D6FB368, 0x1B3D9EA4,
	0x15242009, 0x12A0095F, 0x1CCC6772, 0x0375C88B, 0x0D3CF31D, 0x194D6572, 0x2E8A792E, 0x18DFFF5D,
	0x2229C9DA, 0x1D10E530, 0x06C091CE, 0x2E34B0DF, 0x02ABC4AA, 0x1EA4C6ED, 0x2F05BAE6, 0x2DA75A5F,
	0x2BDFB55C, 0x32594130, 0x041B0085, 0x1C5CC73C, 0x0AF72D96, 0x144795DA, 0x3A1D1859, 0x173F7514,
	0x1419F152, 0x0B5B6A31, 0x31D4B3E2, 0x0571AC55, 0x0AFCD2A5, 0x00B9DCDC, 0x3079228B, 0x18F3EB46,
	0x2BC73186, 0x2F07CB51, 0x1CD65E7E, 0x12C439C7, 0x00B0768A, 0x12BCCAB0, 0x22317FB0, 0x1D8948B6,
	0x33C7A2A7, 0x08995523, 0x36899C21, 0x306E71B8, 0x0B832160, 0x019D7E8C, 0x0746DFEA, 0x0AF4902B,
	0x07F3BC02, 0x3309E7AD, 0x39F9A014, 0x28B903E1, 0x0C64CE1B, 0x2F0D486C, 0x010155AD, 0x1178B7D1,
	0x13DBD278, 0x01DB3577, 0x178276BE, 0x1FD260C6, 0x22ED9A41, 0x3AB2C81A, 0x2C109235, 0x0DD16B88,
	0x11A44BA2, 0x1382B470, 0x1CE6E37B, 0x093245FB, 0x36CE9F84, 0x30F7A39E, 0x236AF7D0, 0x345A58FA,
	0x1FE3E73D, 0x2CC93C8A, 0x1523CB41, 0x01ED6994, 0x22720F3C, 0x09BCA471, 0x0D5E2F91, 0x1C5A231B,
	0x2D34B5F5, 0x04BE7CB6, 0x3980F7B9, 0x32597062, 0x30A11D2C, 0x134C9970, 0x2E04009D, 0x0143067D,
	0x1E79AA21, 0x06434BDF, 0x23C307DC, 0x284A9323, 0x09750990, 0x18B4786B, 0x1184BC9D, 0x2A0E684E,
	0x37ACF7F0, 0x09667B83, 0x1AAB0883, 0x102B1063, 0x29F82C87, 0x038EE215, 0x08A169F3, 0x280A9995,
	0x29E14DAD, 0x17257B8C, 0x1DCD3AB5, 0x0EA8F207, 0x33DA61B0, 0x38C7B4B7, 0x11C1AFD1, 0x1C8E2B80,
	0x2C581295, 0x397134A6, 0x06CDC3D8, 0x0B98E93C, 0x2D12CD85, 0x05D37E10, 0x253061FD, 0x38A47B4A,
	0x2F870509, 0x02573CC0, 0x2AEC995E, 0x0E4655B5, 0x21CB394C, 0x1BFC7D9F, 0x02BD673D, 0x0E4A910A,
	0x396192F4, 0x0BC0560A, 0x1456EDB2, 0x138E4672, 0x22A6AF80, 0x08FFB7A5, 0x1B4005A2, 0x0F2E132E,
	0x02E7F0A8, 0x154F78B9, 0x1578E5C3, 0x2D09262B, 0x00930297, 0x093FE01C, 0x1260F2C6, 0x36132596,
	0x39F4C23F, 0x1C86BDCB, 0x1E8E0379, 0x10B276B1, 0x28C63DB4, 0x11060238, 0x2F189324, 0x24EA2F71,
	0x152511CD, 0x040EE3A1, 0x06C11C03, 0x17872E52, 0x22B5D501, 0x0AA82BCE, 0x1FAC3A02, 0x11BFDD16,
	0x27D71A02, 0x2310A4A7, 0x01D0DB8C, 0x11FC5FBE, 0x14800974, 0x247BE652, 0x2B0EEB18, 0x236A2E8D,
	0x02BD94F0, 0x01980994, 0x3245F400, 0x20F1291C, 0x39409BED, 0x1D26D3E1, 0x11BD6A6A, 0x0EADA37B,
	0x056E1203, 0x18745E29, 0x11D1B93F, 0x0D3A7D57, 0x0DC0BDB1, 0x360E5913, 0x0CDC2442, 0x116C3F27,
	0x345FDF5A, 0x1F8C8250, 0x0424EB90, 0x22913E81, 0x1586CC62, 0x175AEB5B, 0x2F0A4B01, 0x0902961A,
	0x25D9D840, 0x16B9A5AA, 0x3A5ED685, 0x31DB957F, 0x22704652, 0x1384D5E6, 0x254AC7C8, 0x0433EEE5,
	0x19379159, 0x2D2A160A, 0x1FF91EA1, 0x2444569A, 0x1013865E, 0x2EAFAF90, 0x295079C4, 0x25CD1716,
	0x336CA108, 0x3496ADA0, 0x3A4986FE, 0x0C2DA55A, 0x32A19D24, 0x25AEE2F8, 0x304EA6AD, 0x07A61AAA,
	0x3AB524C7, 0x374C2360, 0x151790C4, 0x25581EEE, 0x2A4DDDA0, 0x2634FAC4, 0x0D1F1D41, 0x1CEDAE9C,
	0x07A3F83A, 0x192AE133, 0x2A189335, 0x00D1F4A6, 0x17CCA596, 0x21BAD04B, 0x2CECFB64, 0x0B552E52,
	0x2E779DD1, 0x3A069304, 0x2EE06807, 0x2E558234, 0x07138476, 0x3A7EFD19, 0x0EE7A97F, 0x098BF2B6,
	0x0E11AA63, 0x3B902E93, 0x28D0CC3B, 0x0107ED4F, 0x2F0374C3, 0x0F534CA6, 0x16B712EB, 0x074B54F4,
	0x3A6E107D, 0x29C76039, 0x3AC1D5FE, 0x09808AC6, 0x2C82B868, 0x0FC00EFC, 0x1029E9D6, 0x1C03E1B3,
	0x03390809, 0x2DDE7B0F, 0x086DAC99, 0x166ADE7E, 0x2EAA7083, 0x015BE3C8, 0x0FBF3E76, 0x2BBA58A5,
	0x17C4137F, 0x1ED307D4, 0x18B30179, 0x1BE34DE4, 0x070C8599, 0x3B3FF316, 0x2E819C6F, 0x3A53DDDC,
	0x0C7ADBD5, 0x0720F48F, 0x35E75534, 0x0FDFA6D6, 0x058F1E2F, 0x36ACA206, 0x36F41FE0, 0x27B42A76,
	0x38F8C1FC, 0x144C0FB8, 0x030DED8F, 0x1F86C888, 0x054E268C, 0x031DC363, 0x16D25BFE, 0x2AE0769B,
	0x08CFC83F, 0x1FD5E74E, 0x0E1DB09D, 0x0036C2D2, 0x3B44851D, 0x2A653C75, 0x21FB35DA, 0x158C23D9,
	0x1D871048, 0x2A00BDDD, 0x2427434B, 0x3397EA7D, 0x09963F7D, 0x3187F050, 0x2C12C9E9, 0x11D9D342,
	0x3A6D2663, 0x37FDC7D9, 0x100E28F4, 0x031D2D89, 0x1DAFBC3A, 0x0824D363, 0x1EAB2C38, 0x184ED47E,
	0x13155356, 0x16B460AB, 0x2F4B9DA9, 0x38782878, 0x2A263C1A, 0x131EA0B5, 0x207FC0D8, 0x31B373AB,
	0x23C25037, 0x305B33A4, 0x2B721EB4, 0x2268E288, 0x2791F79E, 0x1DCC63CD, 0x1F0593E2, 0x236D0C3F,
	0x33A86EB0, 0x1C0CD287, 0x045170F8, 0x1D40F1AF, 0x18B11D58, 0x094F2B6F, 0x0ADA4605, 0x022246C2,
	0x11244AF2, 0x0FA61026, 0x1A40A799, 0x395125EA, 0x1BE2F4A0, 0x0929C62F, 0x1A3483CB, 0x00E99BF4,
	0x0F7BA2C0, 0x3B9601E7, 0x1A268557, 0x39D2E477, 0x0344080A, 0x206030D1, 0x2BF27014, 0x31AEF5DF,
	0x2DCB16BC, 0x30BF0ABD, 0x2710C825, 0x16E2D2D7, 0x0394D01B, 0x1E548E4D, 0x0C421018, 0x0B83FD5A,
	0x16EDAB43, 0x0F7DC054, 0x2520D6C9, 0x39A076D6, 0x08C444D0, 0x25F8D043, 0x085B0913, 0x3A40E322,
	0x3272ECFC, 0x2BF1614B, 0x116F8EFF, 0x2F8A31E2, 0x169DF0EC, 0x2007A66A, 0x281D1ECD, 0x03171F03,
	0x2B14592F, 0x09E9028C, 0x1316EE9B, 0x37E9CC17, 0x203511A2, 0x29039EB5, 0x1165CD6A, 0x298E7085,
	0x03E064AD, 0x15B3D2EC, 0x1D8DA5BC, 0x0877D030, 0x3398664B, 0x2F71A64A, 0x23AE2E7C, 0x173313D7,
	0x3846A798, 0x2FF3BF97, 0x0EF93D8F, 0x2983C633, 0x2B4F80F5, 0x19147BF8, 0x18C053CB, 0x0FD24BB2,
	0x09DEB143, 0x1E099817, 0x0365B544, 0x23796F39, 0x278F394C, 0x24E0F981, 0x237A8918, 0x1E061B7C,
	0x2C9CDACD, 0x2FB1FE78, 0x2AB72730, 0x19FFAB0E, 0x2E2808D3, 0x1705646D, 0x1ECBA4DA, 0x2279672D,
	0x30715644, 0x1EFBBA4A, 0x2CC55B0F, 0x34434A0F, 0x365BD56D, 0x04112AC1, 0x05BC5038, 0x26675D35,
	0x1B9CA237, 0x2F8C3252, 0x365A8E9F, 0x03740DFA, 0x253E6F6F, 0x2738001B, 0x0337C9D4, 0x356E43AE,
	0x0B581F0C, 0x1682EAA9, 0x2B17AD01, 0x0E0C4986, 0x3A5B4459, 0x0A7F9477, 0x2FC24297, 0x0114E75A,
	0x2EDD6596, 0x1FED5262, 0x097379BE, 0x202E8029, 0x26B52732, 0x226A12BB, 0x27CDF849, 0x120EC23F,
	0x37CF2966, 0x36F7FDDD, 0x1D3D411E, 0x205942E1, 0x0C5B46D2, 0x10B933E0, 0x3B0A9FF7, 0x21C78B03,
	0x321EB387, 0x29812C2F, 0x23FDC1F7, 0x1EA7987B, 0x33D615A6, 0x265786D4, 0x2ED9B823, 0x11B0DF6C,
	0x1BABFE11, 0x0E8A68DE, 0x307B218B, 0x28CA74DD, 0x1E94EC9B, 0x142A2AA3, 0x0B4F1157, 0x29B7351F,
	0x11F1F162, 0x14D070F2, 0x059763E7, 0x09D8CAC7, 0x33D09C24, 0x1A20B7FE, 0x2AEE491C, 0x0761771C,
	0x26D488AA, 0x3204FD16, 0x239B75A4, 0x3AC40498, 0x2E4D0C4F, 0x10D8DFE6, 0x38C0E273, 0x020CB289,
	0x2E114686, 0x0206550C, 0x383A3013, 0x388509BA, 0x236E244D, 0x2FD500E3, 0x120C5673, 0x22891130,
	0x27033E08, 0x0CF5E5B8, 0x12FA8AFE, 0x2B9847FB, 0x01B43198, 0x386A0246, 0x31C6CA57, 0x02B3ECFF,
	0x1B5C03DD, 0x0B7D05D7, 0x0A59E646, 0x1309D6CA, 0x1A0BB8F2, 0x00BA6416, 0x290688A2, 0x29379F23,
	0x36A60B53, 0x3A29D08A, 0x234B53E8, 0x088B252A, 0x1D3C09ED, 0x0C8DCF7B, 0x2521A7D1, 0x23BFF93A,
	0x33381CAD, 0x0BFA9773, 0x353EEC7E, 0x25601508, 0x19EFBF1F, 0x173D30B1, 0x150553FF, 0x0605876A,
	0x14184EF4, 0x1AF95565, 0x24F6F0C2, 0x31288C82, 0x31923E24, 0x165EC3F9, 0x2DFCDA02, 0x119DECBE,
	0x26D7BAF4, 0x0FFFCB11, 0x2228D1E5, 0x2181D4FD, 0x3398DC1F, 0x3B6A06FD, 0x23CF1F3B, 0x22A85754,
	0x260489D5, 0x39BF15BF, 0x0CC11DCE, 0x302494DB, 0x20B71ADB, 0x033F89A0, 0x216BCFC3, 0x0B079641,
	0x059BB041, 0x2502B637, 0x2C4080CC, 0x311F932C, 0x1D8E19D1, 0x1C0EDEE6, 0x2CA73FD9, 0x24A7CCBA,
	0x0CD018E7, 0x1FFFBB53, 0x2DBE3CAF, 0x0D2C03AE, 0x304C2FCF, 0x3627F2C0, 0x117616CE, 0x265F54E4,
	0x329AD1D2, 0x11651334, 0x1747F3F4, 0x0284AA51, 0x33D2C58E, 0x3702752E, 0x336456B4, 0x145EA0A6,
	0x1B8765DB, 0x1D785785, 0x142FAD0A, 0x01D95418, 0x075BB0C8, 0x3643DABE, 0x36C449BE, 0x1265EA5E,
	0x065106A3, 0x13C4E580, 0x10170D28, 0x05D041FE, 0x1B95E9DC, 0x26078BC7, 0x2EC68C44, 0x0B492CC5,
	0x1F147B06, 0x302FE896, 0x1D54C7B2, 0x23F47703, 0x10E66A79, 0x3AFADC34, 0x29B662F1, 0x239BAF4D,
	0x0EC0B5B5, 0x2F428093, 0x13DE28C2, 0x3B559DB9, 0x04A7296D, 0x23516EF1, 0x324FDBF7, 0x147AA945,
	0x33367057, 0x3417687A, 0x09E2F1FC, 0x0662891C, 0x1F98ECC4, 0x1E68B057, 0x095D225E, 0x1A60EE09,
	0x04293EFE, 0x305001E7, 0x04C3DD56, 0x33996DA5, 0x169B3B6A, 0x13CBCBD0, 0x225B01BD, 0x1B700233,
	0x216E5DEF, 0x23D72CD7, 0x35E50EF2, 0x105012DC, 0x3A9D7BDC, 0x2CA2C3E3, 0x362504A7, 0x1263695B,
	0x2B5A05E6, 0x1F14EDCD, 0x2FF0A637, 0x15D4E220, 0x366EC6C6, 0x1639CACC, 0x3020EC9B, 0x31718A03,
	0x3A70F407, 0x1845F363, 0x079FD8A5, 0x017F9CCC, 0x2E8ACD05, 0x2EB0FFC0, 0x20D98B90, 0x102DA676,
	0x06D099A0, 0x17FFDB68, 0x2F07E23B, 0x2CB9EB01, 0x19D9D597, 0x2549DAED, 0x1D79D9A4, 0x2FBDAC3C,
	0x02F03032, 0x0569CBB7, 0x1818DA5B, 0x36614763, 0x290D1AF5, 0x1282756B, 0x2C7CFEA6, 0x2AE8B0F9,
	0x1264C192, 0x06109E3B, 0x1E48DFE1, 0x19D3FBA0, 0x044498FA, 0x0B1482A3, 0x05CB3CBD, 0x20FEBEA8,
	0x34FAB698, 0x16EABF6D, 0x1661EC55, 0x243B2C23, 0x2C66179A, 0x00413A92, 0x0FFCE78E, 0x1647A110,
	0x10124E7D, 0x0FD083E9, 0x0C36A2E6, 0x0136F54B, 0x243DDDD9, 0x1381CEC7, 0x2AD0D901, 0x032394DF,
	0x10F21DDD, 0x052BAE0F, 0x082638EB, 0x1AD61606, 0x2346A2DE, 0x0EF53680, 0x0570E26E, 0x01A3D317,
	0x22985D2B, 0x1D3BFB15, 0x151F3C0C, 0x1074AD41, 0x05A2432C, 0x33FE02E5, 0x13753E85, 0x3547E34F,
	0x15E2AC23, 0x1F50FC0F, 0x1A5DDE18, 0x0F7389C2, 0x36B8F9A9, 0x1A395950, 0x1A095A51, 0x2817E503,
	0x2F102872, 0x0288426F, 0x1177BA60, 0x20EE2DAE, 0x3B33A387, 0x1FDBEA8A, 0x36B54EE9, 0x178594A5,
	0x03108721, 0x137443A7, 0x041FD606, 0x29DA199C, 0x36A79954, 0x23C966E9, 0x36570B72, 0x39E8A0F9,
	0x3963D260, 0x2ECBD302, 0x09A11745, 0x1BAFA682, 0x16A4C321, 0x21F38F0E, 0x157BF2C5, 0x178EBFBF,
	0x1F78E2D1, 0x05F07165, 0x0985DBA1, 0x0949DD31, 0x0C673446, 0x0EBDCCDF, 0x08F3416F, 0x163A440C,
	0x373C1FFB, 0x2C468AF8, 0x1F1DEF36, 0x27F0FF0D, 0x0C8C9DA8, 0x227E61C4, 0x05AF3B3F, 0x1E876233,
	0x385359DC, 0x13134A92, 0x2C40E248, 0x34F66406, 0x03EFA198, 0x1A0CA2E4, 0x174A4E31, 0x1A29607D,
	0x1C41EE21, 0x22EB7393, 0x0DA20A4F, 0x3B13168A, 0x23003D85, 0x1D6EC5E8, 0x08A3DAD1, 0x222681FB,
	0x0012D28E, 0x06AE57D4, 0x361C65C5, 0x1B2538D0, 0x2BEB62A5, 0x31932775, 0x360C60E1, 0x33287302,
	0x19302EDD, 0x1F968286, 0x3518D8B2, 0x2C954DBD, 0x0063C818, 0x010DA76F, 0x06201DC5, 0x2B4EB84E,
	0x38D155C6, 0x2046783D, 0x00A78721, 0x262F628A, 0x1EEEBCE5, 0x2562556F, 0x09EB481D, 0x0DC39B4B,
	0x3AD96E0B, 0x2BB722E9, 0x1F7804A0, 0x0C1D9001, 0x2E9817FA, 0x16FA0893, 0x3B643976, 0x0C624AEC,
	0x26B1688B, 0x35B2F9B9, 0x0C9AA11E, 0x06294931, 0x28BCB1A2, 0x0D5A7225, 0x1133982D, 0x26A83682,
	0x3208A1DE, 0x0D94E973, 0x35511446, 0x20CA66B4, 0x06C4AD43, 0x2FB2475F, 0x2AC947C1, 0x0CB97058,
	0x322899DC, 0x336F48E3, 0x1F084667, 0x1355F776, 0x15A11CB1, 0x0732D00E, 0x2BAA27BD, 0x2C6DE316,
	0x086C11E4, 0x3022F7C1, 0x1A77B951, 0x30D9D784, 0x16E882B1, 0x368F5810, 0x07635E39, 0x015E82B2,
	0x195FACB0, 0x0400F365, 0x1314DF32, 0x2BE99229, 0x36488D42, 0x141D6D0F, 0x24018B33, 0x16AEB945,
	0x39462626, 0x0C278F9C, 0x184F02D7, 0x120BA975, 0x3788C798, 0x39780E96, 0x008E7CC3, 0x0776B472,
	0x2B7877FB, 0x02BBD1BB, 0x1082E6F8, 0x07AC70EE, 0x2DEDDAFD, 0x147037FB, 0x08E79DBD, 0x0E3F2B90,
	0x37573BF3, 0x20A22A32, 0x1184C224, 0x184C9185, 0x06E6F69F, 0x34996BA4, 0x0FA1EA45, 0x2E8CA17B,
	0x2AE3ACAE, 0x308B1878, 0x21690076, 0x2C00A3F5, 0x36BC1A7F, 0x2D087BE8, 0x03E98340, 0x05365964,
	0x0265B786, 0x2A9F7945, 0x28C52062, 0x11608B6E, 0x11A835E4, 0x11CA548E, 0x08912724, 0x21A8F7F9,
	0x1B47A9C9, 0x0DA832BF, 0x10F8BE46, 0x2359E26A, 0x2C308538, 0x0FC32FC7, 0x302585B7, 0x142EB11A,
	0x17879E92, 0x25F860A9, 0x1BDCE1E8, 0x0ECFCDD3, 0x34F603B6, 0x1F135F05, 0x16B003B3, 0x1DBB2A91,
	0x00711972, 0x0130006F, 0x1E0DF363, 0x05CF3EEB, 0x36FC797E, 0x1F8362B6, 0x3B7193CD, 0x32BBF434,
	0x04A7B616, 0x3A5C7B85, 0x21169731, 0x31D6C043, 0x32821C25, 0x28741CEB, 0x1C0717DD, 0x307DA567,
	0x0BB5A4DC, 0x130BFB70, 0x1D67C980, 0x159F0196, 0x1FB83C69, 0x36E93734, 0x19CE1B5B, 0x0BCEA3C9,
	0x08700579, 0x385A2264, 0x2EC48185, 0x1A58A059, 0x244FC491, 0x04E55318, 0x1668B612, 0x32054D19,
	0x21E58664, 0x1FCB386D, 0x2CD4754D, 0x0672619B, 0x2B0A263B, 0x2BE6184B, 0x0642C864, 0x08BD3DBC,
	0x035C77DD, 0x0479A0FE, 0x369FB42E, 0x165CBAA2, 0x0A31B6AB, 0x086F6396, 0x34F37F7B, 0x04FF5288,
	0x1AB1466A, 0x03E49CE5, 0x2A8EC82A, 0x09F5F1F5, 0x0D58C29E, 0x39D8FC3E, 0x3691BFF7, 0x19DA56B4,
	0x3470C0D1, 0x0CB4F85F, 0x1BE097FD, 0x1EFB44B6, 0x35C6E7B9, 0x2F429D91, 0x132CADA6, 0x08F95A23,
	0x07700134, 0x32620348, 0x1B70293A, 0x2C793E65, 0x2222C5D6, 0x37648133, 0x38E520CB, 0x25C9691B,
	0x1C5302D9, 0x1B0C5F40, 0x2CADD587, 0x01FEF0F1, 0x1B7F785A, 0x0AAB3D96, 0x37BFA4D8, 0x3281F10A,
	0x3A1AB828, 0x25F9E994, 0x31D94CF8, 0x2F8FC7C3, 0x2F9C01C5, 0x2E0BD734, 0x3B765EC4, 0x0A3D3723,
	0x357A6B49, 0x35FD3274, 0x29C12E29, 0x287A748E, 0x20176445, 0x3A26DC12, 0x091AD9CE, 0x2D99C765,
	0x0ED673B0, 0x19DC1CB9, 0x19DEADD4, 0x099CF066, 0x1663C476, 0x34DD34B9, 0x25F125DC, 0x0F2412AB,
	0x254F0FF9, 0x239E92EC, 0x230E95D7, 0x05BA24C4, 0x0B907A1B, 0x39FD56F7, 0x1634BDB2, 0x1764F523,
	0x26BE1B06, 0x0981F127, 0x315D190D, 0x2915FBFA, 0x22C2153F, 0x0059CDCC, 0x1F5354B2, 0x0482E057,
	0x245A5878, 0x03FCDBEC, 0x1F9E96AA, 0x25DA95E9, 0x24D5104A, 0x2C7594D0, 0x11E68F13, 0x26A4CB29,
	0x0311CB71, 0x12704E24, 0x1823EAC0, 0x22707ABA, 0x2A05E19B, 0x1D4FF7DF, 0x2FAC640E, 0x098B77AF,
	0x14AC397C, 0x018D6932, 0x3228ACDF, 0x24E5FA67, 0x33CD0C0A, 0x0274FF58, 0x02DFFECA, 0x0652C3B7,
	0x22BAC9D8, 0x04D2F700, 0x393A5AF8, 0x2A13BCCD, 0x0729A086, 0x1F360B78, 0x134BA933, 0x0BFFF411,
	0x2A38BB89, 0x3B92F733, 0x26D06D81, 0x15D06420, 0x0CE92050, 0x191F02DB, 0x175B91C0, 0x1E594260,
	0x27FB9364, 0x06946FD4, 0x09F4DFC0, 0x1597030D, 0x30B3456C, 0x2A6B605D, 0x21C9F3F3, 0x0941FB76,
	0x38DDF43C, 0x3762502C, 0x10C47B4A, 0x337051A6, 0x2941BCD2, 0x2D535457, 0x03A91E3D, 0x2FCC8622,
	0x3AB8343F, 0x32C32A91, 0x20915A1E, 0x34C1051A, 0x03EF0AED, 0x375CBF76, 0x0B517880, 0x37FAF342,
	0x1F7A3633, 0x13D3D895, 0x0431B6B3, 0x286976F3, 0x342AEFF2, 0x22761913, 0x12A40529, 0x0CA5EDBA,
	0x22169FF9, 0x0D89B554, 0x2663A8C8, 0x029277BF, 0x3AC652AE, 0x28D952B7, 0x032DBBE5, 0x2461DD28,
	0x14A85686, 0x2F580A68, 0x214CF735, 0x2BE534AC, 0x1A5297C4, 0x0FCED053, 0x3259200D, 0x2D4C7B55,
	0x316637FD, 0x0849639C, 0x008B4A8D, 0x279F85F8, 0x16EB7482, 0x1660C610, 0x1109339A, 0x2699362E,
	0x18157366, 0x2D7AC85D, 0x3974F584, 0x1B04B5AE, 0x2CF6A92B, 0x2DCEF57F, 0x38CA3F13, 0x36230C68,
	0x16504A5E, 0x2357AB15, 0x05D0D11D, 0x1046769B, 0x07CE4D15, 0x0299362E, 0x39259084, 0x0DF81855,
	0x06DB0FAF, 0x350F0700, 0x2E76A1DF, 0x13862DD4, 0x261E8E88, 0x065B07AA, 0x172A2BB6, 0x2280348E,
	0x10A76B99, 0x14764E41, 0x2829125E, 0x1C95441E, 0x1861D575, 0x0D7AA922, 0x234074ED, 0x02ABE471,
	0x1ADD6DAE, 0x06E5A079, 0x316B992B, 0x170E254B, 0x270EBA38, 0x1455D181, 0x09E2F807, 0x11833F2F,
	0x0B6F31E5, 0x293B83FC, 0x2E9FEC00, 0x032147C5, 0x14D60563, 0x36642F83, 0x279F5FE4, 0x08727DFA,
	0x00850FA2, 0x330725FE, 0x3734A880, 0x1CB252D4, 0x394A24AD, 0x10745202, 0x36374B30, 0x33ABD2F0,
	0x073FE3D1, 0x32BFC070, 0x04D73A02, 0x29E9EAC6, 0x31A11B9E, 0x353C8647, 0x35092AB5, 0x118EC28B,
	0x13A8BB99, 0x214C6547, 0x243C410C, 0x3085FD23, 0x18EB38CD, 0x2EB56B97, 0x1933FF45, 0x093A9E07,
	0x13DD9A59, 0x043E60C3, 0x1E399DA0, 0x126DC1C9, 0x1F7825BA, 0x2586CAA9, 0x2028E2FD, 0x23A38A6B,
	0x0E2CD050, 0x00AF2009, 0x02AAAB3E, 0x0505683E, 0x382195B9, 0x27C82F78, 0x22D7C3F7, 0x190A1492,
	0x2DB14F3D, 0x1E76C993, 0x13ABBC9B, 0x0BA07E06, 0x233B4ECB, 0x28445036, 0x0A29A514, 0x2062EF1C,
	0x39ECA355, 0x06C65266, 0x145DC82C, 0x1784EDB7, 0x2C2C1A4B, 0x27D8FD17, 0x130030FE, 0x3762DC49,
	0x11B89947, 0x27FE37A8, 0x1AA371C2, 0x00655A03, 0x20E2F3F4, 0x0CAEC99C, 0x25DC0575, 0x273D27E2,
	0x1CE032E8, 0x327F194D, 0x0667275D, 0x17FD94A8, 0x2953A6CC, 0x18C0162C, 0x3046D357, 0x0854F1E3,
	0x0DE130F5, 0x2CE7E5D7, 0x3A6F5D63, 0x09A31429, 0x334C95CC, 0x2EEED741, 0x2580590C, 0x36CCCAE3,
	0x39A14511, 0x2812EB66, 0x0165C96E, 0x1A193152, 0x305E3176, 0x2DD47056, 0x2239A832, 0x16733BB7,
	0x1D2EBE0E, 0x29539331, 0x04A875AF, 0x0DFFFFC1, 0x10587746, 0x14503A3E, 0x00D592C7, 0x35AC0187,
	0x0D7699AD, 0x1A490DD4, 0x0AFA8B53, 0x1679E255, 0x29DFD507, 0x1AC2E152, 0x110BD7B5, 0x07E65159,
	0x16E87043, 0x3B780209, 0x1196599E, 0x3297B009, 0x0441D9F2, 0x0E9CE5D3, 0x0BA571E2, 0x2A481B9E,
	0x24609EC4, 0x3901C900, 0x0CC73AB8, 0x1064640F, 0x2BB0CDEA, 0x0A779D57, 0x3983F65F, 0x1BE76B4E,
	0x33EE0647, 0x35AB45AE, 0x098B7F17, 0x39CCA1A4, 0x14276BF4, 0x3897C565, 0x386B6203, 0x2D8344A9,
	0x3341ACDD, 0x107AB3B1, 0x2B6192A5, 0x27B30DBE, 0x033AF230, 0x30BF4E18, 0x21DDF662, 0x1646B94E,
	0x0F7E3443, 0x2A073FB6, 0x280422C0, 0x06346802, 0x21358B78, 0x0BFB8BEF, 0x14703334, 0x180112DD,
	0x2194B8F1, 0x1C9D53D9, 0x142D75B4, 0x3851CCFD, 0x172F405A, 0x36C8446B, 0x005580A6, 0x2683ACA0,
	0x2E661630, 0x35B40153, 0x06B6C577, 0x393E8D16, 0x310FB8F5, 0x09C9952C, 0x33A1F571, 0x2CE21EED,
	0x038715EA, 0x2B292BD0, 0x1F5C19ED, 0x315C18C7, 0x30647A31, 0x0BAF00D7, 0x13839EB7, 0x2CF786C6,
	0x3A09A695, 0x0A530DF7, 0x00421A34, 0x31534138, 0x1CC3F3AA, 0x31A1E009, 0x0AAE6833, 0x107B939F,
	0x2D796F2A, 0x296D78DB, 0x1B2A892F, 0x20367310, 0x3A7C2CFA, 0x38EDE59C, 0x10CDAC36, 0x2362D395,
	0x28B17666, 0x18588ECF, 0x0BC053F8, 0x3326BE19, 0x3441CDC9, 0x12A33958, 0x0B19B84F, 0x1CD8051C,
	0x0F1FE591, 0x1119992E, 0x053F9282, 0x344374D5, 0x32545591, 0x3B71E7AC, 0x2786BE91, 0x09BE3F12,
	0x08C816ED, 0x0081A1D6, 0x3073ADDB, 0x227F1009, 0x2489ADCA, 0x15CA8CE7, 0x0174D1ED, 0x254EF5E5,
	0x147F706D, 0x0BB8E5CC, 0x315C01A2, 0x266FF7B7, 0x1DD12646, 0x30A27794, 0x352B0B67, 0x106679D9,
	0x07DA9523, 0x0C675972, 0x09799559, 0x2AC78AA4, 0x2FB76582, 0x32DA28D9, 0x38BBCB9C, 0x1D7D23FE,
	0x20C93D65, 0x02782314, 0x109428D9, 0x0E3429F3, 0x26CDA4C4, 0x1F0A60A0, 0x0AAAB02E, 0x0EAE1865,
	0x28D2F30A, 0x0EAA111E, 0x08B2FEF0, 0x0C7796F6, 0x3B7A2E80, 0x201AF9C4, 0x3A05CCC8, 0x2FCAB466,
	0x28294D4A, 0x0C064CAE, 0x3587EEB8, 0x0CB4DB59, 0x0C5DEF4B, 0x3B2AED13, 0x08EAC1C6, 0x01A96BF0,
	0x23ED451E, 0x2AD96729, 0x2F4039F4, 0x338E427D, 0x2F7BA49C, 0x08671DB3, 0x1636EBA9, 0x0F32A902,
	0x0797C185, 0x000E297C, 0x35613D4C, 0x1E8A9581, 0x0597C874, 0x377B8353, 0x397B356D, 0x0FC5B802,
	0x190CD63E, 0x2FDDDEC4, 0x22E643F8, 0x336C6B81, 0x34F01233, 0x3B2E4BAF, 0x38798ECE, 0x1C143E26,
	0x26BB8F1F, 0x1EE20678, 0x28E70014, 0x05A1D502, 0x30CE7702, 0x1E4E0EAA, 0x25A3A2C2, 0x2C4E7CFC,
	0x34531671, 0x1D15395C, 0x1B555BB4, 0x0CAE3D15, 0x0B02665F, 0x14CFF619, 0x218BB1AB, 0x05EF2B5D,
	0x0129640F, 0x1384F5A4, 0x1C1B0006, 0x2D71C27B, 0x228BA995, 0x108D10C5, 0x2E532BE6, 0x08127E22,
	0x2CCA2AC6, 0x044824DF, 0x33274834, 0x2D893500, 0x24A5A694, 0x0B7DB34E, 0x2F788556, 0x36A39326,
	0x0466E9A9, 0x1D35B37A, 0x06441D6F, 0x0F523E9F, 0x1A23F7E6, 0x2EA0B4C9, 0x185C0218, 0x2CF05F39,
	0x0EB68815, 0x01FE5CFB, 0x02EEC684, 0x03DE865A, 0x36F249E6, 0x139191A0, 0x2C1D2001, 0x16BC15B5,
	0x3737874D, 0x0BD78F6E, 0x23CC01E0, 0x131997C5, 0x37A71A61, 0x18C65328, 0x04878703, 0x2E457102,
	0x1FBE1C73, 0x0927C2F8, 0x251FAD55, 0x2F45F4F7, 0x1765867C, 0x156C0CF3, 0x2530DFAD, 0x121E9A72,
	0x061033F5, 0x2CD687B3, 0x35ED347B, 0x2729448F, 0x38C92F5F, 0x2395D178, 0x19D48B8D, 0x01951832,
	0x060F45BA, 0x0A95A9AD, 0x1AFA7D0B, 0x297AAE1A, 0x2DF88229, 0x1A0B1FF0, 0x3076C66C, 0x0292C239,
	0x0273964B, 0x3B15A7D9, 0x3868C751, 0x1FA4BE09, 0x1AA6AF7C, 0x05664789, 0x351AED68, 0x2B73E44F,
	0x1BDC636C, 0x048C14F0, 0x2BDB8868, 0x3323A692, 0x1A08A028, 0x0D68CD66, 0x2A2D21A5, 0x01DED0BF,
	0x0957FAB0, 0x2179499E, 0x222F7041, 0x200038FD, 0x14F39381, 0x315FDCDB, 0x15B1BFFF, 0x2D6203EE,
	0x15BD0984, 0x32115AAF, 0x2A1C648C, 0x139085E6, 0x029EEE48, 0x2C87EDD3, 0x026689ED, 0x2FFD512C,
	0x097834CE, 0x3B8EBE49, 0x31817CD0, 0x1DCE5D0B, 0x3725F085, 0x1063C428, 0x1FE54519, 0x3B19DDB1,
	0x2CA67B89, 0x129412A1, 0x0FD4D816, 0x2EAC4756, 0x0DD825DF, 0x18CF687A, 0x29041F75, 0x3B559938,
	0x181BBA6B, 0x11B15E10, 0x1F5D1DF2, 0x2F50BC58, 0x07B191F5, 0x33ADC8A4, 0x0A53D808, 0x2C8BC690,
	0x2FB44C5D, 0x15B1E2A4, 0x36D0CB50, 0x0BC7C092, 0x0C9D645A, 0x00BF7246, 0x31C885E7, 0x1A533615,
	0x2BB6A3A6, 0x1F73DEBE, 0x0CDEA2DB, 0x2F38F099, 0x0194F5D1, 0x05944644, 0x03E5CF99, 0x30173240,
	0x1D99C9B2, 0x1F36A6D0, 0x0BE3273C, 0x124DEA6D, 0x29C821A3, 0x201F4801, 0x319E0646, 0x371CC7E9,
	0x103EAE9D, 0x212F3C0A, 0x345EC359, 0x2A3E3FAB, 0x2BDCE898, 0x069A0A04, 0x39D6CC4F, 0x07F70E59,
	0x0307A058, 0x224AAC42, 0x06142721, 0x138EE8A1, 0x1C6062D7, 0x2004FEF3, 0x177D7EFB, 0x30AA5935,
	0x1E9F98AF, 0x37DBC7BB, 0x03DC91EE, 0x015EA14F, 0x3A1E396C, 0x1FE6D361, 0x2B1806ED, 0x0C0F1C83,
	0x25169891, 0x351D8EB6, 0x38387E46, 0x330E6653, 0x3026D933, 0x035100B6, 0x2E7D2B5A, 0x1D93694D,
	0x22A894FA, 0x32887DC8, 0x3AD5E135, 0x1C6C8F3C, 0x109F8730, 0x20823A7D, 0x052EAC89, 0x1C516967,
	0x06BC1FC0, 0x3A62A679, 0x18100508, 0x1FDB4E7C, 0x25B36C2B, 0x250F054F, 0x1BF1F0FB, 0x161B1FAE,
	0x20D50863, 0x18299E34, 0x3538BF27, 0x147154DD, 0x2D9367BC, 0x228CA06B, 0x208D3A75, 0x181887B8,
	0x10C8B69E, 0x179C659E, 0x071CBE9E, 0x281D6E9B, 0x1DFF1124, 0x01CC3843, 0x103DC726, 0x1F18CF82,
	0x1575D02B, 0x15CBF95E, 0x33BE8B31, 0x2BEC534C, 0x05CBE804, 0x107B5E45, 0x0F1071B0, 0x18522313,
	0x0909CBD6, 0x06A6B59A, 0x1ADB5A5E, 0x11AD4F85, 0x0A1C429D, 0x1CF025C9, 0x03A2CB29, 0x01BB9F06,
	0x18378E12, 0x10D00C49, 0x1BD6C574, 0x12FAB2F0, 0x0FD80A98, 0x1E754515, 0x35941480, 0x1CF97687,
	0x227A55C4, 0x2FCF9262, 0x18363F35, 0x3B980A5C, 0x3269C8F8, 0x152E95C5, 0x13AD2B41, 0x082A6872,
	0x1129430B, 0x111A9CC3, 0x253FA7C1, 0x23AED982, 0x30F88A97, 0x374F7F6F, 0x01E76091, 0x18A2A6CF,
	0x0B778D30, 0x27F4027E, 0x0508CE4A, 0x2B7C2DFC, 0x04075BD0, 0x288216B8, 0x1DAE1F24, 0x2B475827,
	0x21C37D64, 0x3075B305, 0x20667C5C, 0x27ED9477, 0x11E24C52, 0x34EBF690, 0x04F8E6AE, 0x1F3483D1,
	0x1127D938, 0x33FB2899, 0x334B0D81, 0x16938457, 0x14E1D8E5, 0x24CF9A45, 0x2B5DC4C7, 0x15C3A365,
	0x2318E717, 0x062A20C1, 0x26AEB418, 0x14F44DB9, 0x27D18B84, 0x167BA48C, 0x12C6D105, 0x1FDC3287,
	0x0F308E42, 0x1088BAB5, 0x2E63E387, 0x16BA647D, 0x219D4D5D, 0x2B0736AC, 0x08105A0D, 0x1FF22FE8,
	0x28322968, 0x191DD482, 0x1907F575, 0x24DD843C, 0x3ADC18B7, 0x30229B53, 0x340D91A8, 0x1FBB2865,
	0x04C1DA12, 0x00DE88BA, 0x1DBBD265, 0x0BA4CED5, 0x3808E192, 0x1C90DEF7, 0x30D09977, 0x35CF8186,
	0x37F1082A, 0x09E98D56, 0x31EE903B, 0x38E89B41, 0x3A61137A, 0x2C271074, 0x39837D7A, 0x3500AA91,
	0x0791E033, 0x0BC0E95F, 0x16027405, 0x362B3B50, 0x14CA7759, 0x2AD4E154, 0x1EDEBF69, 0x08FC6A91,
	0x12DF843E, 0x0882CE99, 0x36F5C69F, 0x00443A65, 0x04166550, 0x1907A164, 0x1A05E860, 0x28FB6995,
	0x29889A9B, 0x1FDE5664, 0x15F0EB7D, 0x0714DE00, 0x093BE229, 0x37748425, 0x197BE2D0, 0x034DD629,
	0x3A67C3D1, 0x06413CB1, 0x2565D277, 0x0EAFCC90, 0x36860E72, 0x02DBEF4B, 0x1AF97BD2, 0x34CC4CEF,
	0x3177AECA, 0x00F0E5CD, 0x173B7BA3, 0x278DEA29, 0x12FFEDD2, 0x17780FFB, 0x08706E39, 0x3AFFD92F,
	0x11C6430A, 0x274914C1, 0x1391698E, 0x2FE394FD, 0x1D521408, 0x226D79B9, 0x138FC2CE, 0x1DCF5EA0,
	0x2AC58240, 0x39346FC1, 0x17826B04, 0x13C131C8, 0x1814F989, 0x019FA888, 0x17BEE0CC, 0x27195A9A,
	0x15BC432C, 0x38B0E0E7, 0x27C9DF83, 0x16935EDD, 0x328DC6EB, 0x032F446B, 0x1B6D4A4D, 0x38D30F83,
	0x0064E381, 0x342ED4CC, 0x06339859, 0x185C6FAD, 0x331155AA, 0x0E953079, 0x3AD392EF, 0x2113E9F6,
	0x3B287980, 0x0A42DA0C, 0x141085AE, 0x2B66B4A5, 0x3A34C20B, 0x064A83D5, 0x2A76346B, 0x28896FE8,
	0x314605FA, 0x1F651BDA, 0x0AD0D361, 0x01FD2BB7, 0x18CDEA9A, 0x17007671, 0x1B03E17B, 0x1F5C8ECF,
	0x1F1112B2, 0x0FF8404B, 0x35ABFF2D, 0x08EFE07A, 0x25570CCF, 0x2D07319C, 0x17C5DEAE, 0x3384A512,
	0x2D478FAD, 0x0FCC87A7, 0x301E1231, 0x347F91F8, 0x07955EC4, 0x2E70FC58, 0x2B1F72B6, 0x0628FA41,
	0x298C35AC, 0x2A816BAD, 0x0FB8FC0F, 0x21BC25DF, 0x265B966D, 0x0C7715DF, 0x3279686F, 0x3A31E334,
	0x2D3618D3, 0x0EFDC7AB, 0x359009F3, 0x1E5F717B, 0x2D8B9741, 0x02ED6DEA, 0x02872CAA, 0x009AF93A,
	0x0A98116A, 0x13EA3749, 0x0A714726, 0x1CF9BB1A, 0x28A2E20D, 0x2FD024C5, 0x13AEEDCB, 0x06DDE151,
	0x348CE2F9, 0x338D1E2F, 0x2BD56309, 0x07FFCBB0, 0x0CC23CFC, 0x24020F64, 0x2EDAB359, 0x18249D9B,
	0x328F96D7, 0x0D9D7912, 0x08A28C3C, 0x0C70E5CB, 0x093D71AC, 0x1EC1874C, 0x1AC58053, 0x2E35D33A,
	0x041A9A03, 0x0A8D38F8, 0x0B2C12A5, 0x3B66FB15, 0x39C25E01, 0x26896A88, 0x20D1D1B8, 0x0834F4E4,
	0x205E973C, 0x2DDB83F6, 0x26E6B5EC, 0x0BFC074F, 0x3B16D0E8, 0x21D28ECC, 0x268D3B89, 0x23EBA7DA,
	0x1888D94F, 0x08ECA6AC, 0x1DBCE580, 0x1EDEF64A, 0x20BF292F, 0x19C25A62, 0x085F13F4, 0x177A41E9,
	0x16F39F31, 0x059D508A, 0x0F64CDCB, 0x2BED0EFB, 0x1A8FB9F8, 0x14BDE69D, 0x26F9E761, 0x20C3685E,
	0x1F9DD8CB, 0x2934E4A1, 0x3AA74AD8, 0x11E1FACC, 0x094211E7, 0x069CE808, 0x141C82B9, 0x053D7B7B,
	0x11648B07, 0x240CE4FD, 0x1C72E280, 0x335B02E2, 0x07442519, 0x2567C5D4, 0x1AA31396, 0x234C3562,
	0x0821053B, 0x29C5BA28, 0x0DAA75F9, 0x27A33670, 0x22E12D22, 0x36F6B575, 0x2A400537, 0x05706931,
	0x0393A2B8, 0x2F71BAFC, 0x0FBE40EC, 0x01956803, 0x1D19C542, 0x32F8DE85, 0x031BF33F, 0x106548CC,
	0x29942F89, 0x050AD2C3, 0x23653DD5, 0x35AE7601, 0x02934593, 0x0C8BC1CE, 0x01027F82, 0x2DBAF8B8,
	0x123890D6, 0x2508B895, 0x1AE798C7, 0x2B125939, 0x0891CDFD, 0x21E905D0, 0x040EADE3, 0x01C289D1,
	0x09A4D028, 0x25C5CFBC, 0x393EF449, 0x0BCE3F18, 0x0D63E014, 0x2776FBA8, 0x2A141BBA, 0x08F53221,
	0x1ADBA1ED, 0x0180DC06, 0x2DD0D6CE, 0x27B559AA, 0x1F976219, 0x0287DFFF, 0x2E25788D, 0x04AE50EA,
	0x14CA54E8, 0x327F79FD, 0x27D7031C, 0x19FED923, 0x1E05DA5E, 0x09C56717, 0x1C681555, 0x16DB9D16,
	0x26E492F4, 0x2486D8E1, 0x20F4F9D7, 0x1D419371, 0x1EBFAF29, 0x182A9632, 0x1267B967, 0x0236EC31,
	0x1221CB85, 0x15D129BC, 0x37867DC5, 0x0A0E8954, 0x1C585EDB, 0x2C031DCA, 0x32B0DC56, 0x0C466EF7,
	0x39990493, 0x386AF42A, 0x3A33A1FC, 0x2553C009, 0x00415EAF, 0x1342B4A6, 0x199A6533, 0x1B02290E,
	0x079CA179, 0x15694A93, 0x08B6077E, 0x29B38117, 0x03314A69, 0x373CC91C, 0x29C385BF, 0x35BC8581,
	0x070D4AB1, 0x00EF19E4, 0x161B0C26, 0x016E5FF5, 0x0A543E98, 0x090980CA, 0x0F753926, 0x39A2BC1E,
	0x0BBA1791, 0x2AD52255, 0x272CF5DE, 0x12A09D1A, 0x2552BB34, 0x1B8E524C, 0x103E9071, 0x0410F910,
	0x252AC0DE, 0x20536CA3, 0x389CF37C, 0x38EB953C, 0x0B9CD08A, 0x18CFE276, 0x067066D8, 0x24FDC000,
	0x2A08FE92, 0x253618AD, 0x1B50FF82, 0x0887635C, 0x33150645, 0x22D503D2, 0x02E952B1, 0x08547831,
	0x217B0CEC, 0x2147100D, 0x086158E6, 0x29FA57C6, 0x382391AF, 0x2E818402, 0x04F6B857, 0x38FFBDC5,
	0x2A71B797, 0x2C464FB8, 0x271DF49F, 0x040390FB, 0x206C788B, 0x1A3D7B29, 0x220F3A41, 0x042516D9,
	0x0BBAA304, 0x1CF939EA, 0x037B0FE3, 0x30F65CA1, 0x1ED3BA4B, 0x15DCE08B, 0x08F4914D, 0x39A79F53,
	0x1AE2B450, 0x36EB9C53, 0x15B39489, 0x24FEE810, 0x3AEE659C, 0x094E38D8, 0x26368B91, 0x24177631,
	0x3299FC40, 0x1E6FE6D6, 0x0974950C, 0x31957FEE, 0x198108E6, 0x2D5EB636, 0x2BA90481, 0x0F4138DD,
	0x0EDDFBDC, 0x0B134EF3, 0x08744CDD, 0x1F990E53, 0x2E339E25, 0x042843E0, 0x2F0F94CB, 0x118AC186,
	0x11B4A11D, 0x28833BF2, 0x2ED589E3, 0x30AF752C, 0x380CA357, 0x15AD3EC1, 0x2DEE79DA, 0x3537E50B,
	0x010DE2EE, 0x35AC6200, 0x1A2C5B35, 0x2C950D8B, 0x0C0B99C4, 0x24CC4347, 0x0D2DA5D8, 0x19FDB3B8,
	0x2BEDA643, 0x2A245DA6, 0x0EA3F4B9, 0x02871735, 0x30D7E33F, 0x3B45CE5A, 0x29D39072, 0x0FA5961A,
	0x27922E2C, 0x2B025634, 0x36E077C9, 0x127F7A6E, 0x2D54E199, 0x0EBA314A, 0x2D4CC621, 0x272069B4,
	0x392D8668, 0x26DE10DF, 0x1D612217, 0x0562F5D7, 0x26980B9B, 0x0329EC18, 0x0AC12740, 0x22E3A101,
	0x1A85445F, 0x062C3747, 0x11DF7752, 0x2D0FE7AF, 0x2F270D77, 0x01C15EEE, 0x0AB536B3, 0x1AE494C2,
	0x16C9599E, 0x1D5FF8E0, 0x34093CD2, 0x36D4FADB, 0x17F5CC1D, 0x37C19476, 0x2BDA3FCC, 0x1050E237,
	0x0CF31588, 0x33BAD7DB, 0x2BB2A026, 0x06FF0A71, 0x09681C2F, 0x1522C5D5, 0x200A2EBB, 0x33566AA2,
	0x196EB660, 0x0CFAE22E, 0x1DACCFE7, 0x127851AC, 0x019195F0, 0x197EB43E, 0x27EA2506, 0x2DF90F5B,
	0x38581EA2, 0x3ACFE5F8, 0x2989631A, 0x327D278F, 0x103DFD09, 0x24751995, 0x033922AE, 0x3A32B69E,
	0x0E469A69, 0x1C03E82D, 0x138F6AF3, 0x00C9241C, 0x04014CC7, 0x25C4EDF6, 0x261167F0, 0x04312D51,
	0x2716160D, 0x374076AC, 0x127D6EFC, 0x0D79BA03, 0x0912625D, 0x271DC48D, 0x04005C36, 0x1D49489B,
	0x3B9881F4, 0x3794B5EE, 0x3932A941, 0x00CCA258, 0x2DBBA1A1, 0x0EB22CA0, 0x2CDD74AF, 0x2D71356D,
	0x1D6D1549, 0x2FC1DA9D, 0x13C7F521, 0x0CBCAEF7, 0x31F28FF8, 0x01D063DE, 0x2D90CC9F, 0x13F82EF4,
	0x30C50ED2, 0x1F09BF11, 0x0FB12789, 0x14514F70, 0x1D1A8988, 0x05D894F9, 0x2B1AF92C, 0x3A59F1D9,
	0x32E81549, 0x1B9D677A, 0x328F773E, 0x393A0B81, 0x18E88CC4, 0x1462CBC6, 0x2957873A, 0x3432DD36,
	0x12B814BC, 0x166DEC55, 0x1B552540, 0x2C23EF34, 0x14FDC7F3, 0x34BFF2F2, 0x3190627F, 0x08C53658,
	0x0E64DC78, 0x2E59C9C0, 0x25953096, 0x281F5171, 0x22B6C307, 0x016CD55E, 0x3B5291A1, 0x117F3C2D,
	0x23B7E6D8, 0x14578D46, 0x1147CED7, 0x389E2CA9, 0x199FDCFF, 0x05E69154, 0x1A1E77E5, 0x31E98E64,
	0x1584F927, 0x0C0FA344, 0x28A6DA9D, 0x0CCE82F2, 0x38083F1D, 0x04BA7164, 0x1120167A, 0x21E42C6A,
	0x24E2A81C, 0x2EB83853, 0x1EAA94CC, 0x075BC413, 0x0EC4847E, 0x06600417, 0x0DAD402C, 0x150FC878,
	0x16CC92E4, 0x270B27A2, 0x0E986615, 0x017FB695, 0x25B3C57D, 0x3743FFA1, 0x396156E6, 0x0AED483B,
	0x3043410C, 0x2C84E9B1, 0x2694A45B, 0x2CD78627, 0x25FE10D9, 0x2F0957C0, 0x0025930F, 0x2FA59222,
	0x15CBB9E5, 0x0E0F6CBE, 0x3B788F08, 0x2869BE13, 0x07732E41, 0x01FB1B22, 0x0EECC50C, 0x34C7FCC5,
	0x243A7B61, 0x1F9E59B1, 0x224AD3CB, 0x17D07D44, 0x1A1DE690, 0x236FFB14, 0x02159F7D, 0x148177AE,
	0x09DD349A, 0x306D279A, 0x1B66D893, 0x38277A05, 0x055D2D35, 0x0742DE13, 0x14F9CA78, 0x15502067,
	0x378D7D97, 0x2B75A022, 0x14601041, 0x2395D43B, 0x28F31424, 0x09BBFAAD, 0x2A51321B, 0x02FBB885,
	0x2E300BF3, 0x0105C2AE, 0x016EADC4, 0x0FF6382C, 0x2354DFBA, 0x301154EA, 0x375EB966, 0x0881EA4B,
	0x380BCCA1, 0x00FAFE66, 0x36C4E2EC, 0x20A143BE, 0x0A09A3B4, 0x2CB92ABB, 0x2D603291, 0x1C855ED6,
	0x040D38C3, 0x07CA23F0, 0x189FC4D2, 0x2BFDA385, 0x1618EF58, 0x078236CB, 0x10A9C9F5, 0x32C134BA,
	0x34C8687D, 0x103E614A, 0x286888F9, 0x00DE0912, 0x17B0C5D8, 0x101293F2, 0x34142A17, 0x10EFCFC0,
	0x2CEB1944, 0x29101FF6, 0x1966AA37, 0x30EC4FEB, 0x31CBDCD8, 0x21E6174C, 0x2E93413B, 0x2E5498D3,
	0x09D26D21, 0x29CE8D1B, 0x21D3CEF1, 0x32CFAD7E, 0x3A103044, 0x075117C5, 0x329D9976, 0x39F9B5F7,
	0x13EE8059, 0x11FE0420, 0x2D45232F, 0x2F18514C, 0x23432713, 0x11C27714, 0x1E12B563, 0x31826A7A,
	0x268A6BF7, 0x2BBAAD8C, 0x1D575D76, 0x34B56DF2, 0x0177F1A0, 0x19083600, 0x2B6FFC34, 0x040DDBD4,
	0x1F6FA9D1, 0x31DEEDBC, 0x0B0E70D2, 0x36D5247E, 0x27B54E0D, 0x20B391FC, 0x27005D5C, 0x2CDC030D,
	0x359AA54C, 0x1A9BD56E, 0x1410AA3F, 0x106530AE, 0x3877CABA, 0x189FA30D, 0x3B4EC349, 0x208D42EC,
	0x324BB557, 0x250CF4F8, 0x049A0813, 0x38A41552, 0x05DCD4F0, 0x1CA485AA, 0x25807F9A, 0x2CE612E2,
	0x08BBE7A0, 0x0F8CD9DC, 0x1CFFFC77, 0x1820E8FB, 0x22F1B83F, 0x1D05D785, 0x1EB3477F, 0x0D9B03A6,
	0x1D2D584C, 0x2720F787, 0x3211C980, 0x285E68AD, 0x049E265D, 0x361A5F6D, 0x2225202A, 0x1ADDFBBB,
	0x2F76B5E6, 0x39E97BCC, 0x39E6F6C7, 0x29A484F1, 0x3B573A2C, 0x19BC721E, 0x0F8D18FD, 0x2A9FC039,
	0x297A7DC8, 0x32ACE39A, 0x06FF7079, 0x01330367, 0x215DC333, 0x321850CB, 0x370E1919, 0x24EF0CB0,
	0x2EEAC121, 0x34DC2086, 0x0599E64F, 0x0BD22D39, 0x04A5B234, 0x09AE513C, 0x24088C11, 0x359F9FD4,
	0x055748DC, 0x2E7A6D8E, 0x3653181C, 0x369FAC00, 0x2A2A2D00, 0x307D3FD4, 0x107F9612, 0x0DFC868C,
	0x2DC70089, 0x24B4E078, 0x0F7445D5, 0x0CB1E378, 0x0A47F093, 0x25D2DF34, 0x10390547, 0x2FC84527,
	0x124DAAB9, 0x2397F808, 0x31C1E1C8, 0x35C45F00, 0x229FB522, 0x30391B74, 0x2390B637, 0x0A52164F,
	0x24C038B3, 0x18EC091B, 0x140011C2, 0x356D1794, 0x1D6F5605, 0x0928934A, 0x0DA61D4B, 0x3096E399,
	0x253E44E6, 0x37CAE127, 0x39961C49, 0x10563B62, 0x0F1AFB64, 0x2D1EA389, 0x3250ECA9, 0x1F02A0D5,
	0x34E90DF3, 0x380C9EF2, 0x1B83D141, 0x2541E37B, 0x192749A0, 0x332E6BC8, 0x0D8EDA44, 0x1782C643,
	0x3AF4228F, 0x1C560A67, 0x35BAE183, 0x1ADD7E78, 0x0855A6C5, 0x00D8394D, 0x37998491, 0x2205F6E9,
	0x3566E7E8, 0x0443F672, 0x00674168, 0x0C885784, 0x3A36EF25, 0x1A6FE60E, 0x22D372EE, 0x1A0F2F65,
	0x1B3EF746, 0x132B2190, 0x39C9C660, 0x03863BA1, 0x281A3665, 0x129782E3, 0x3B7A286C, 0x38D76D80,
	0x01A0C0DF, 0x11E90586, 0x0A0B4AE0, 0x13F85220, 0x0585790C, 0x30310FC4, 0x2E6C5150, 0x04F8D5F8,
	0x32CAA38A, 0x1913EDA4, 0x210A1E51, 0x0FD440A5, 0x067E474E, 0x142C7169, 0x07DAAB64, 0x11E447F0,
	0x2304665B, 0x221EE767, 0x26A184F1, 0x0B00E028, 0x0CE7F9E7, 0x3385E956, 0x35933D56, 0x0094D4A7,
	0x0F8FD45E, 0x0417CD89, 0x11C907D9, 0x076FAC16, 0x0ED97B73, 0x0277D193, 0x1A2A0866, 0x32D430B7,
	0x36CF250C, 0x26D9B798, 0x13CF7584, 0x2E038108, 0x1B521815, 0x2E35CE02, 0x0C4C0B50, 0x128DDF52,
	0x1381564F, 0x2D83D02F, 0x27024560, 0x1B9A96E5, 0x09F226F2, 0x0DB228EE, 0x28364626, 0x2BC88F6C,
	0x3A09A858, 0x11901492, 0x1F0F96FF, 0x3AD14740, 0x1EFBB23D, 0x17875F04, 0x03C1C18B, 0x2588AE06,
	0x2B6AD9BA, 0x1A26ADEE, 0x1C3C4107, 0x16D6C1E8, 0x11B53600, 0x2696D9F2, 0x1272EF9D, 0x0F38BBFF,
	0x3567F380, 0x3897A0F6, 0x11FD4C2C, 0x0B0429FA, 0x1FC9F1A7, 0x2CB59EDA, 0x013EC93D, 0x09F6F225,
	0x1D057957, 0x122D2ACF, 0x008246E9, 0x0B1C7834, 0x1892D588, 0x14ACF4E2, 0x22B6026C, 0x10A61AE3,
	0x08DF0851, 0x331EE363, 0x3B33E513, 0x2E33EAFB, 0x2F41CA74, 0x30881965, 0x134E910B, 0x22F2E42A,
	0x20C81A1B, 0x164CA028, 0x0580C1AE, 0x1E341DA3, 0x341932EB, 0x033226C7, 0x1AAA1137, 0x15802F55,
	0x250043F3, 0x05770BF2, 0x067D7384, 0x14F57073, 0x3B6175F9, 0x1A301621, 0x2F18E643, 0x033A8160,
	0x3A313B79, 0x36935E1F, 0x072F419D, 0x1C1781A3, 0x154F6A29, 0x12CB65AF, 0x08ADCBDA, 0x3494C14F,
	0x1F0AF14B, 0x1D5B7136, 0x0400BA49, 0x22B5CF71, 0x37413237, 0x12E05F01, 0x24999976, 0x30F5AE4E,
	0x285D501D, 0x14E3F62E, 0x10F3CE54, 0x235B85BA, 0x04835257, 0x35BC93FC, 0x343F594F, 0x302033F8,
	0x1400C6C6, 0x269495A6, 0x01444B0D, 0x17AA4D1A, 0x1052C80E, 0x1CDA84B5, 0x20C64C6D, 0x0586D9D4,
	0x1324E775, 0x310C79AD, 0x1F88D072, 0x02ABAB93, 0x3AECA734, 0x069E63BB, 0x262B856D, 0x229EC73F,
	0x36D826F9, 0x2289EC7A, 0x30D1501E, 0x184E5818, 0x18276A92, 0x2E7EC7D3, 0x1C4324F6, 0x3B44C24C,
	0x1BBFCFD2, 0x38E8F059, 0x2DA55778, 0x2C32C8AB, 0x16A88207, 0x1519AE47, 0x1F210923, 0x279CD004,
	0x2FD55657, 0x19910489, 0x22985338, 0x33E87D35, 0x0F32954A, 0x1FC428F0, 0x2A1CC896, 0x0F0236E6,
	0x2F26E417, 0x06121717, 0x2D6C74C9, 0x1448341E, 0x156701A7, 0x24E84457, 0x296D2A67, 0x37860960,
	0x1031734C, 0x1FDC7163, 0x2738A02F, 0x13987E24, 0x087E3546, 0x18D90800, 0x0CB33082, 0x30646103,
	0x29E28713, 0x2B8AB8CD, 0x33BFB070, 0x0A722AF1, 0x37A9A79E, 0x3A3A653A, 0x23209957, 0x28542A8B,
	0x068E03FD, 0x2272BDA7, 0x09BCD490, 0x32BD20C3, 0x001EF390, 0x0A983E8B, 0x25FB28AA, 0x1F385C25,
	0x0277BF3F, 0x2EDFE9B1, 0x28CA0390, 0x1FA3F1A3, 0x2A8F7CBB, 0x2C828F3A, 0x0002DFE0, 0x1539E0AA,
	0x18CC1193, 0x03696105, 0x29A6B9C9, 0x0C4E1056, 0x31DEF9B2, 0x04DA2797, 0x22EFCE27, 0x04656E06,
	0x25A8C4B3, 0x07F6AB0A, 0x0E1F99DC, 0x1437C2CA, 0x2F8C7CF9, 0x0AAB993C, 0x336C40DB, 0x299E1C1F,
	0x099ABBEF, 0x12207F9C, 0x25A817E8, 0x27DB675A, 0x08AF14BF, 0x01B3CB43, 0x2CA10A4D, 0x2789CA4F,
	0x27752364, 0x19E97B5D, 0x0F977D84, 0x0783F738, 0x2166A883, 0x12E101E0, 0x116AF88E, 0x19E5D2A6,
	0x104920E1, 0x0EA98588, 0x0E830FA5, 0x1D02E30A, 0x0B57F844, 0x3276EDC8, 0x02B0DCE3, 0x0AA9A119,
	0x3488F6F8, 0x268D859B, 0x14E46F47, 0x0DEF5FD3, 0x1D3152BE, 0x0D7C7E94, 0x1E583260, 0x3B472AAC,
	0x31CF4341, 0x1FDC6DAD, 0x27F5B08A, 0x06202BE7, 0x361E596C, 0x0FD1A15F, 0x0B102CD7, 0x094F17EB,
	0x1C3452C0, 0x33816312, 0x2B2F5396, 0x0CBE769B, 0x364871E6, 0x1B6C81F2, 0x2DDE23ED, 0x0905B0DE,
	0x2589DE81, 0x1B2B665E, 0x03131D41, 0x185ADD40, 0x187B0450, 0x22DA3FE4, 0x3B7D4AAE, 0x0361244B,
	0x11DA3485, 0x0A715A42, 0x20705A32, 0x00A2D003, 0x0328DCBE, 0x29C72091, 0x21D44D7D, 0x116E23FE,
	0x1AD76DD4, 0x0CA37B7A, 0x2C2FFCC5, 0x24B82C45, 0x2171885B, 0x22C838BC, 0x308A504D, 0x196744C5,
	0x371E847C, 0x08047404, 0x1D654E96, 0x2BA757DA, 0x265F8486, 0x0104E7FE, 0x184095A2, 0x16BAA2D3,
	0x27265E80, 0x06AC2B4C, 0x120AAE45, 0x0F1AB6E8, 0x0346918E, 0x1CCC2FB1, 0x177FE801, 0x040C6F94,
	0x3A24A715, 0x1D9563DD, 0x1FC70AAC, 0x0E33D322, 0x287D9C71, 0x330456FE, 0x2ECA78BE, 0x2D40FB4C,
	0x1CF3D55C, 0x3B331026, 0x138D663D, 0x378E939F, 0x18BF53AE, 0x1F3499AB, 0x320C08F1, 0x298D7BC5,
	0x353B4A22, 0x2C939F59, 0x0E368431, 0x0ACAF900, 0x33AF7C3C, 0x2FA33DA5, 0x27F696B0, 0x0CC155B4,
	0x0C41E20F, 0x11D487A9, 0x393D7960, 0x366DA5A0, 0x22215EDB, 0x0FD0BE96, 0x1606F839, 0x27E1C38B,
	0x124C8B22, 0x1CFBE027, 0x05840463, 0x26919D41, 0x10345F8B, 0x3A408ECA, 0x025909C9, 0x394D0AF3,
	0x3432EB76, 0x00E19A87, 0x08EB3A35, 0x13887309, 0x25AF6106, 0x06A948A1, 0x083DDAC4, 0x02CF5C5D,
	0x21A472CC, 0x2D88963D, 0x2B610E10, 0x2F360727, 0x35147408, 0x0AE2DC3E, 0x1C4024EE, 0x33E65AB6,
	0x193ED3EE, 0x0C51C4A3, 0x369625C1, 0x1126C516, 0x05109FF2, 0x1073A5E1, 0x37E558A8, 0x3463B4B3,
	0x26F06233, 0x314DFC57, 0x04891CCB, 0x0BB26EC8, 0x36953223, 0x2FBEADD2, 0x345D824E, 0x1E820787,
	0x37BC38A2, 0x137A0F75, 0x368FC979, 0x1E9D1CB5, 0x12D34D29, 0x2570319E, 0x2478A0E0, 0x20ACBF61,
	0x2618D2BB, 0x3691743C, 0x1ACF7053, 0x20D93B2C, 0x2B82B32F, 0x08E0B6AE, 0x0D6A52CE, 0x0EB898B5,
	0x25265122, 0x065CB6D3, 0x03CD68FB, 0x2AE235EA, 0x39AA1D8B, 0x2627112F, 0x3211A0BA, 0x2D411D63,
	0x26DB1554, 0x2C2619D0, 0x1A91D3F7, 0x1F97613E, 0x05362110, 0x0509721D, 0x365DA2EC, 0x0EE6C4F8,
	0x2532B161, 0x0BD720F5, 0x26354FE2, 0x28DC52CB, 0x392EA28E, 0x180A179B, 0x3835AE69, 0x1CCCFCB3,
	0x0C8D6287, 0x1B279E3D, 0x1FA9F605, 0x2B7B8E76, 0x0CB47388, 0x0FDFAACA, 0x07A584A3, 0x1575A2CC,
	0x0F6EFCEB, 0x07CD61DE, 0x0F78702E, 0x37F8971B, 0x329B9BE5, 0x3B87E82F, 0x35D96A4C, 0x0B2A9374,
	0x1995B347, 0x165A09DF, 0x25F6D6AE, 0x1B43B271, 0x186CE724, 0x12BF1850, 0x1D1D42A8, 0x09905C57,
	0x2A1DE0E1, 0x19276522, 0x38369994, 0x1CF17459, 0x31DE71CB, 0x1E85551D, 0x3632608B, 0x21CDA724,
	0x33C360CD, 0x1044C602, 0x2DB881EC, 0x01ACF97F, 0x3881DA82, 0x1069EA74, 0x2115D4C1, 0x0B08CB19,
	0x008F91DE, 0x1D5F78D3, 0x14B92A27, 0x340C4F58, 0x2CBCA16F, 0x335AD896, 0x216DAC86, 0x166B2ED7,
	0x152012C3, 0x30FB5D9D, 0x1D2BAED6, 0x075DFA9F, 0x2EFBF8E1, 0x0B55A07B, 0x2416A714, 0x19DDDDDE,
	0x05A6EDC0, 0x1848870E, 0x3B41DDDE, 0x0B868380, 0x08BA7BC7, 0x31EEE936, 0x3060F3AD, 0x1F7C4127,
	0x159684AA, 0x111DB0B6, 0x18B437B7, 0x1AD62A91, 0x09BBFF0E, 0x0DA9915D, 0x1FE5BD68, 0x1097C3D5,
	0x0EE20D75, 0x32217B20, 0x08F2A7A9, 0x1B9D60AD, 0x0681A79E, 0x335A7718, 0x0E878079, 0x1887AA07,
	0x2B9DD686, 0x1D4FC3AA, 0x1162ED91, 0x25E24387, 0x0A7940B2, 0x03C9DE1B, 0x0D57DD04, 0x0B0017A6,
	0x218D9C48, 0x17EFABF7, 0x105D69F2, 0x128230F7, 0x1167E274, 0x00F088B1, 0x235A6326, 0x0C207210,
	0x08169D1F, 0x2FC03CD6, 0x3044108B, 0x0E419B7B, 0x0AD9D986, 0x193B0287, 0x370B0B94, 0x36D44D46,
	0x254B1CF3, 0x2DD1F792, 0x036A22A1, 0x230CFC43, 0x1B33506C, 0x0C2DE0B4, 0x357AB203, 0x22477C5E,
	0x134F0ABB, 0x37DC7EE0, 0x1E996251, 0x2CC91287, 0x368D3041, 0x221BE2E8, 0x2D161EA3, 0x304AD12C,
	0x340927F4, 0x262CFC74, 0x179BA69A, 0x23D67CBD, 0x2491321C, 0x1EC3A910, 0x220F5F39, 0x16C72FDC,
	0x2C98DC48, 0x2ECFF361, 0x10346CB0, 0x09C23F21, 0x0A66CFBE, 0x2B39CD57, 0x12BD8C2C, 0x3B2BC225,
	0x2D30BAFD, 0x1D5A89DC, 0x0292305B, 0x1C4FBD1A, 0x3B3F2513, 0x23B97B7B, 0x31A6E98C, 0x05790E9F,
	0x33068729, 0x34C9CD22, 0x0B553FD3, 0x240F1911, 0x34C6D00C, 0x027D8CC6, 0x114B2B4B, 0x1EC138F6,
	0x08098EE5, 0x2BD2BA40, 0x07121A5A, 0x14A15FC5, 0x01D92B52, 0x1A7FEC69, 0x2554CC21, 0x217DA176,
	0x295A425D, 0x031B65D4, 0x0911E6D6, 0x00675A01, 0x1B55FBC0, 0x049CCFFB, 0x0044E612, 0x14CA52D6,
	0x0DEB0006, 0x2AA76E54, 0x05BC9EE6, 0x31304A4B, 0x2EE87ECD, 0x2DF17B0E, 0x23F0A28C, 0x3605376C,
	0x14C857C9, 0x3690143B, 0x02E76DB4, 0x1869B8BB, 0x1D1191FD, 0x199F3502, 0x37AEAC5A, 0x29F912D5,
	0x33D723F3, 0x1DFF5CB8, 0x366029B0, 0x218ABA23, 0x27D81AA3, 0x1147C3BF, 0x385A0897, 0x22024E06,
	0x218D34F7, 0x11E4EFF0, 0x07CC6C0F, 0x26AA24F6, 0x389E64A5, 0x17F2D099, 0x29ACC560, 0x37681C2C,
	0x04116201, 0x1E88351C, 0x2680303A, 0x187AE898, 0x3584DA74, 0x0C67C9C9, 0x009F69E4, 0x11E9AD8F,
	0x36E977DD, 0x223B60F8, 0x1111ABAC, 0x0CF75672, 0x335E906A, 0x32C72E2F, 0x1738F2CA, 0x24EB45B7,
	0x0354AF24, 0x2FB24485, 0x1627FB16, 0x06792AA2, 0x314F4B00, 0x316D6751, 0x16E6763F, 0x1E37301E,
	0x0FF0FA98, 0x0CE6955C, 0x3067747C, 0x3A87BFEA, 0x34374BFD, 0x03CA3373, 0x32D1ACFF, 0x2E2FF118,
	0x34B26AA4, 0x31306E7C, 0x088C57FA, 0x1369A401, 0x09371164, 0x2D5422AA, 0x3635B88A, 0x3B45FB66,
	0x2CB4AA3B, 0x01C7D747, 0x37B333D7, 0x2F15CE83, 0x2E54EEC5, 0x317B09B7, 0x2943B851, 0x3537A022,
	0x11C353AB, 0x2AA785F3, 0x02E226BA, 0x2768C1F0, 0x21346441, 0x3166F1FB, 0x06B8A259, 0x13ECAC56,
	0x2822F647, 0x0747F516, 0x08FD6B7A, 0x01E3BF23, 0x0304B566, 0x045D6536, 0x04E30786, 0x0E712A2E,
	0x30A3EC7B, 0x29EB3D48, 0x0DCE266C, 0x04140F9A, 0x01699651, 0x11A929C0, 0x1A010C3C, 0x0A120142,
	0x2E1F8ACE, 0x0E8D1549, 0x0B434E3B, 0x32F776BA, 0x0B1ACEFE, 0x36D3EB6B, 0x2CD1F344, 0x27D53A04,
	0x343F7C86, 0x0EAC26DA, 0x0E973666, 0x0229F203, 0x353B6EF9, 0x28CA1454, 0x17DE30FA, 0x2A20C2AB,
	0x15295142, 0x39132643, 0x160A23AC, 0x18A9EDB4, 0x2F073D93, 0x327239E6, 0x37F05493, 0x00C2954D,
	0x269510DA, 0x21A33F4D, 0x375FC191, 0x0EA29D1E, 0x2822B1DD, 0x2A5F50C4, 0x08738425, 0x0CCDD65B,
	0x1EFB745F, 0x344910EF, 0x2E260D63, 0x192789C2, 0x322CB4BB, 0x213769F6, 0x1FB0A01A, 0x1CFC441A,
	0x3291269D, 0x32C514AA, 0x0EB3F9DE, 0x15E96D69, 0x17748D93, 0x3292DF55, 0x0B1B6F02, 0x247DCF5F,
	0x0F3C3E3D, 0x37891657, 0x18270280, 0x336AE9CE, 0x260DD186, 0x24E73CC2, 0x0AB5C835, 0x28D05F5D,
	0x1A5EB641, 0x0566794E, 0x1D4BB72E, 0x09087973, 0x23D52466, 0x2506E985, 0x0C4A91D9, 0x35D2ED44,
	0x28F7B445, 0x0862AA0E, 0x1093836E, 0x30D5FDFB, 0x02E55F2E, 0x1E0AF88D, 0x070ED0D6, 0x14077029,
	0x2362C044, 0x22017663, 0x2F4E74AF, 0x1F2717D7, 0x33A84AB9, 0x103D652E, 0x30529202, 0x36D445EA,
	0x03F5F386, 0x2FE36AF5, 0x11393463, 0x0607AD22, 0x327DAC0F, 0x29EA086B, 0x1A6E730E, 0x2CC67990,
	0x30EDA1FA, 0x0862F1DF, 0x08347C5C, 0x36D79CAC, 0x298DD9DD, 0x133E5BFE, 0x02AF09AC, 0x10F9D5C3,
	0x2DCC8C65, 0x0BC30F49, 0x13106C8B, 0x351E2275, 0x132672B7, 0x09AC2874, 0x0496F856, 0x1E49C251,
	0x1ACD1DB8, 0x0092AB1A, 0x289908BA, 0x20C2CC5F, 0x010F8B67, 0x1C7E9879, 0x33081B66, 0x1B784AA6,
	0x0BA1C54C, 0x122C254B, 0x1B667C0C, 0x1FB4E359, 0x3A754A07, 0x15AD9862, 0x0A3BE243, 0x30CE2884,
	0x004BEE6C, 0x0081F184, 0x3ADB4206, 0x158DF947, 0x07888011, 0x0C545BC2, 0x2852CD26, 0x2C8976AD,
	0x1D770C4F, 0x0B21ADAA, 0x079E7EE7, 0x16C58845, 0x0F1F17ED, 0x375A06FB, 0x18E7FA7E, 0x138B7F85,
	0x1C0A48A1, 0x1A281C02, 0x13BF985C, 0x1B5FA0BB, 0x1B3A31F0, 0x12F3FF79, 0x12EAD9B2, 0x04852691,
	0x0A39E848, 0x2F3F2590, 0x18D4D917, 0x210864E0, 0x2F910BB5, 0x33CFE70C, 0x03D2974B, 0x30F470B0,
	0x0F2C8C8D, 0x226ADD4F, 0x3AA16DF8, 0x252BD380, 0x00CD1CA5, 0x13EEFB23, 0x3AAFCE24, 0x038DEC04,
	0x0D7FAD72, 0x0727F021, 0x0F872470, 0x1EDB2CEE, 0x2FBE9A64, 0x1F7F6268, 0x17ED164A, 0x31BF83BF,
	0x007473F5, 0x20C2BD38, 0x28967D4D, 0x13F37967, 0x12354458, 0x1E3DF5B8, 0x1C722694, 0x0F23D63A,
	0x10C9A578, 0x1C5B92AC, 0x07CE6024, 0x27221656, 0x003C47F3, 0x23C9F7D0, 0x285E7779, 0x11CEB689,
	0x3854680D, 0x0DE3710B, 0x125DC0A1, 0x086B7900, 0x352949C8, 0x37E35A46, 0x1522F3E6, 0x0BB83323,
	0x370434F9, 0x1A3FDA88, 0x359ACD13, 0x1E5C346E, 0x1D89E360, 0x0FE4C6D3, 0x3601776F, 0x2E35483E,
	0x363E6D28, 0x16D42F29, 0x1EA20761, 0x30716988, 0x12F6373C, 0x3B486870, 0x3500A010, 0x3415B7FB,
	0x2F9C981C, 0x3813D4C7, 0x1D51B54F, 0x18E1C065, 0x269AF3B9, 0x24D2B4B2, 0x1C729BE6, 0x2F4E306C,
	0x2F01BEC0, 0x31A0D31D, 0x0820C010, 0x237C6E0D, 0x25F71FC0, 0x0C815791, 0x334F41EE, 0x23C6D732,
	0x14F613D8, 0x129C6BFB, 0x0989E371, 0x2694C220, 0x2116C555, 0x0A053A4B, 0x0E9BD52E, 0x0B0989FB,
	0x1A4FD52D, 0x261B670D, 0x0B890F98, 0x250BE769, 0x2AB11911, 0x081176BF, 0x1E6B848D, 0x13602264,
	0x1354B49E, 0x017D445E, 0x07B55D11, 0x1A7BDE82, 0x1E8D1359, 0x067D78EB, 0x2A245091, 0x1C05BBB9,
	0x050CE8BE, 0x1F7C7793, 0x15547160, 0x176C4191, 0x2D768A64, 0x2BF2A591, 0x180CDBD8, 0x1E2FF274,
	0x10C846EE, 0x050BE94E, 0x2015204C, 0x1A7E3010, 0x35514E86, 0x3994C3A3, 0x32C029B2, 0x1963CD24,
	0x17C092A3, 0x00D394C0, 0x2E28716E, 0x2BA9735E, 0x29F8E24B, 0x2549B7DD, 0x1ED8792F, 0x3B3A2A13,
	0x3002F690, 0x0069551B, 0x27AD5F39, 0x24FC86A6, 0x1854BF3A, 0x0B7997AE, 0x283A81AA, 0x380BE116,
	0x2654469C, 0x1AA0B3D8, 0x0B3B6A5F, 0x29BA8BCA, 0x2678D6F9, 0x05429BFF, 0x1B49B05A, 0x1A5C6361,
	0x28862198, 0x21E9C7CB, 0x303A0206, 0x09FA5BA6, 0x33CA0623, 0x17543422, 0x2946E9DA, 0x34A313BF,
	0x2176EB96, 0x2BA988CA, 0x33DEB12B, 0x34B76ACA, 0x1169C43B, 0x2832D155, 0x01F48664, 0x1B3EDBCB,
	0x2A6E3FA9, 0x0690A844, 0x2842B62F, 0x3A92F1FB, 0x2ED8A929, 0x37F00592, 0x133A0ED1, 0x08A13E1C,
	0x20F684F5, 0x2346C833, 0x023F2D9F, 0x36375D82, 0x23CD95D7, 0x1252910A, 0x0FCE8CEC, 0x086A17B4,
	0x2686DB8E, 0x1F5DB1A2, 0x116B3E2C, 0x1E6D8E18, 0x3B044F35, 0x09D462B3, 0x17CEC262, 0x388C9E2E,
	0x1F6FED5A, 0x1CADA4B0, 0x2B669378, 0x28E48AB9, 0x0B127015, 0x151616D4, 0x31F5A063, 0x20A07B2C,
	0x17368AEB, 0x34506DBD, 0x0F1EF963, 0x0B447A6A, 0x0B0C5B50, 0x247C629A, 0x172C51FB, 0x22665DB8,
	0x2D389C0D, 0x16774FF7, 0x1F818911, 0x21515BB3, 0x310E3505, 0x35D5F6DB, 0x1981D0A8, 0x15D473D5,
	0x356EB321, 0x134956C9, 0x35C7E84B, 0x1051D732, 0x218FE2AF, 0x26E7C4C8, 0x369492E6, 0x09F750CA,
	0x2E332262, 0x032FB91B, 0x21D9CC7F, 0x2B6FF61A, 0x311A6B6C, 0x1E06566B, 0x2A96E2CA, 0x267F17FF,
	0x22C98AF6, 0x0047A165, 0x38F5F4F6, 0x17082310, 0x2EC6B836, 0x3A95EE0A, 0x0778ED30, 0x1FA56ED6,
	0x2D1320D3, 0x22BC4C86, 0x06E1DBB4, 0x3380438E, 0x348F05AB, 0x09C95274, 0x2BE951BE, 0x2767BD12,
	0x369F0A7E, 0x213DB240, 0x35B8C387, 0x3147E5AF, 0x00AB497B, 0x26294F89, 0x0F3142FC, 0x1C94BCDE,
	0x375BC1A2, 0x2FF07CC1, 0x07D30C08, 0x10030B86, 0x2098D87A, 0x317DF133, 0x302FC1A8, 0x26EBEBA3,
	0x22A05446, 0x29BCCF2A, 0x3022A2F1, 0x13008454, 0x0A0C0A36, 0x2E2CB053, 0x20C841DC, 0x1B49C458,
	0x286E9266, 0x2B27932E, 0x15328233, 0x1EAC9D10, 0x1AD4D766, 0x0BA2567C, 0x0A39A310, 0x0BE957FB,
	0x2EF8BAF9, 0x1592CFB3, 0x00671904, 0x124FB583, 0x32F8F785, 0x0D50D3EA, 0x18B99FBD, 0x1C3E9D13,
	0x34109F4C, 0x147E2214, 0x09B6C701, 0x2CF52C47, 0x34F6BFD0, 0x30030541, 0x2761D801, 0x2A3F1514,
	0x096097E9, 0x263C1E9A, 0x3A25B3A2, 0x068ACB0B, 0x36FBFEDF, 0x2C134283, 0x3783A4FA, 0x0EAC3877,
	0x12E9E3D3, 0x3082B591, 0x17082FA9, 0x2C090A35, 0x26E7D36A, 0x365293CC, 0x096E7479, 0x34451166,
	0x056C56EC, 0x318AB4F5, 0x1572D236, 0x10387B91, 0x04DACEC3, 0x1FBE75CA, 0x2B0B0449, 0x08384C09,
	0x2BEC090F, 0x1AC44445, 0x38F921D2, 0x16004CBB, 0x114B521C, 0x005BFB76, 0x24A7DDDF, 0x2E994A8E,
	0x2C5FFB8D, 0x0B6EF874, 0x1DC3B4D8, 0x130B9E70, 0x1D9389BB, 0x204C750D, 0x2D380727, 0x0CA9267C,
	0x35373FD3, 0x233A8CDF, 0x333617D5, 0x14A19A15, 0x199F1A58, 0x34166371, 0x12E4EFD7, 0x1FFEBDFB,
	0x1D6556CF, 0x096BFCFA, 0x30916B51, 0x28030F0A, 0x287F1DAC, 0x13E5E1F7, 0x23E897A0, 0x0FFD5CA7,
	0x147DF610, 0x39331F5E, 0x18938077, 0x29459D02, 0x308A030E, 0x329FD94F, 0x1BEA04B2, 0x268FC039,
	0x0AE7585F, 0x053C5EA3, 0x3AFF2427, 0x0D0546E4, 0x148C7970, 0x188BF721, 0x39D2E729, 0x1763F53F,
	0x079EAFAF, 0x03024F67, 0x0EE136A7, 0x3A28202A, 0x0FC4370B, 0x271CB451, 0x080ACE88, 0x27CC8D9F,
	0x1571390A, 0x288631D6, 0x1D92D414, 0x19943FB9, 0x1FD3F6BE, 0x3A6665AE, 0x1E298851, 0x0B832BF1,
	0x29D011C1, 0x1B1A9F11, 0x2FBE26FE, 0x3A8CDC5C, 0x2D267033, 0x206E05E9, 0x181FA990, 0x1CB67385,
	0x375B0B01, 0x24895055, 0x2F2DB934, 0x2E6766AC, 0x0BF4601F, 0x21B52EF3, 0x01A31EF9, 0x2C7CBC33,
	0x1EEB5B7A, 0x0499598F, 0x13E0DD1E, 0x202D95ED, 0x10CA6072, 0x2055CF14, 0x15BBDEF2, 0x0B7A07AA,
	0x129403E9, 0x0DBA839E, 0x25AEA8B7, 0x36476FD1, 0x09A876F0, 0x0A3B25D4, 0x2D1E5FAF, 0x396BCA86,
	0x0824CD05, 0x305DDD19, 0x18844758, 0x05A3AEC3, 0x2DEAAA3D, 0x1E980CBF, 0x35F40707, 0x23621DF3,
	0x2190C595, 0x09FF2595, 0x18F79DF7, 0x1B4240D2, 0x18D8D843, 0x16F707E8, 0x1D40C6D8, 0x2F656E80,
	0x08C37DF1, 0x0579C89A, 0x0F170BAD, 0x17D25741, 0x1101DB45, 0x2D7063BD, 0x0B8DC191, 0x3AAC6FA7,
	0x16A12953, 0x22C4D877, 0x09132A17, 0x1211851C, 0x3122E921, 0x0F09A338, 0x34CE751F, 0x23959BD9,
	0x37BFBA7C, 0x0677C8EC, 0x0EE88758, 0x30E184A3, 0x32B0D98A, 0x23063631, 0x38115B93, 0x06B16D24,
	0x21084589, 0x167B1F5C, 0x18D56455, 0x0B5939A8, 0x071853EE, 0x335A8F3A, 0x38A68147, 0x15DE2747,
	0x328D140A, 0x03803CBA, 0x186F7CA7, 0x1866F20E, 0x23836F9C, 0x1D179574, 0x1A219869, 0x24F134D7,
	0x23A45E4E, 0x325CFD89, 0x07C31F22, 0x0BFC54BD, 0x0082524B, 0x152A1E08, 0x2A8F1617, 0x2191DFAA,
	0x313C2913, 0x0F20AD20, 0x12BBD953, 0x3A302356, 0x2A5909D2, 0x20918230, 0x0C9BF840, 0x2C26FFE0,
	0x08EBDEE2, 0x353F6FE2, 0x28E88282, 0x11922177, 0x06C3A87E, 0x3837B20A, 0x1438691A, 0x13FE427C,
	0x3956C987, 0x0E290939, 0x34D59D52, 0x0F046BC2, 0x06433E59, 0x2673B113, 0x1AE7365B, 0x2A15D555,
	0x2F0FBECB, 0x0C2F68DB, 0x1E273288, 0x0B5D39DC, 0x21BC8BAC, 0x1555D140, 0x0B879967, 0x2FBA2B38,
	0x1EE675CE, 0x172CF5CF, 0x2D6493B9, 0x21CF6BA5, 0x2E025825, 0x1F833AB7, 0x219DE9D3, 0x2B720C01,
	0x1E216991, 0x170071C4, 0x21B5C611, 0x3B77945D, 0x0CC6A311, 0x145FA444, 0x213BAEF0, 0x0F1539EE,
	0x0FF62A27, 0x2E8DA3C4, 0x052C4779, 0x1C21162A, 0x2CFE1F5B, 0x04EBBB5E, 0x39E885FB, 0x092FDD8A,
	0x0A8B0EE1, 0x0F70DF60, 0x0850363B, 0x25D2CE6C, 0x2641C797, 0x352FB9F3, 0x2BE3589C, 0x0DCF3B38,
	0x24210B0E, 0x24F2D05A, 0x22A98CA8, 0x1227258E, 0x26C983C9, 0x01FA3115, 0x1793B3DB, 0x1D7A2441,
	0x2A1A81D3, 0x027C84ED, 0x2D43DB9D, 0x2933F3FB, 0x07E19681, 0x28DDAF02, 0x0994FCD3, 0x242CF757,
	0x10E1EA57, 0x33A86259, 0x0A5AC648, 0x2CC450DA, 0x1E08AFEE, 0x36E9A4A0, 0x075658BA, 0x2851DF4E,
	0x3831D6C8, 0x336AC15C, 0x083BC7EF, 0x238A0D24, 0x1006F2EC, 0x0C852005, 0x0CBF3A8D, 0x12AF8D2B,
	0x0DDA0B30, 0x1C47BAF4, 0x1BBADE95, 0x1F946F26, 0x324020FE, 0x2284CECB, 0x060501AC, 0x0D126363,
	0x14FD4CA6, 0x380C03BC, 0x3AA597DD, 0x1D4BB3EC, 0x288F84B4, 0x09583ACA, 0x1498EC41, 0x36E96E13,
	0x3576E055, 0x2F472829, 0x22D5B71A, 0x0870D927, 0x26898F15, 0x081B1DD5, 0x0A8FFF8B, 0x15577427,
	0x0C7789BE, 0x27D994AC, 0x217ADE32, 0x15221FAB, 0x01036C11, 0x37782AFE, 0x0869A207, 0x361A33D7,
	0x2F41E2C2, 0x0CF269B8, 0x307A41B6, 0x1384AB8B, 0x26EFC604, 0x1A8EF516, 0x0CB2356B, 0x31DFF585,
	0x332E1930, 0x302E3ADC, 0x2D3CDE49, 0x25453535, 0x2914227C, 0x210DB023, 0x1A620249, 0x1D3207D0,
	0x00FA6443, 0x34F529CD, 0x24B528F0, 0x1BD71BA3, 0x0E81F825, 0x39C6E02D, 0x227F46CA, 0x3461FFC4,
	0x04C2D89B, 0x0450992C, 0x05F758A9, 0x1ED4F169, 0x0CA10FC1, 0x07058DE7, 0x013BF2DA, 0x0621563E,
	0x25D3751B, 0x095B1763, 0x1C645EB1, 0x1656C025, 0x2295FE8C, 0x0B70693A, 0x16254877, 0x1632719F,
	0x3A12D07C, 0x36F1CAB7, 0x30A95825, 0x1BD12837, 0x0D91DE7C, 0x2747128E, 0x1341D5A4, 0x3B437A8A,
	0x140C242D, 0x17BD8D07, 0x30CAA6B4, 0x234D5B5B, 0x1911A22C, 0x3840EC2E, 0x02CE9406, 0x1FB298D9,
	0x13305BA0, 0x21358DA2, 0x3216781B, 0x1CE7567A, 0x08E99271, 0x24857863, 0x3B52D3F3, 0x3163E01F,
	0x3299DB9A, 0x2D76CC76, 0x2EEF50D0, 0x270ED307, 0x187A1744, 0x2FCC6A2E, 0x3ADEFCD0, 0x0B5D0F64,
	0x0A58EA5E, 0x17298E29, 0x24C2C169, 0x0EB8C1C2, 0x1DA17104, 0x0BE2C0EB, 0x025B462C, 0x0D49B016,
	0x03F6F80B, 0x0A026A8C, 0x37DA1AF7, 0x38E8FD40, 0x158FED53, 0x36BC5963, 0x36F26CCF, 0x199E484F,
	0x1EE9EFFC, 0x30E5EB08, 0x0132B284, 0x202B2A46, 0x3266243C, 0x07D84DA5, 0x2CC46D0F, 0x2F0B75BF,
	0x39103375, 0x04D49B65, 0x36B67505, 0x1C697857, 0x268D04B3, 0x0BDB4596, 0x30EA3851, 0x19DA185B,
};


// -- Initialize built-in game offsets databases

// Black Ops 4 SP
std::array<DBGameInfo, 1> GameBlackOps4::SinglePlayerOffsets =
{{
	{ 0xA56E290, 0x0, 0x91F9090, 0x0 }
}};

// -- Finished with databases

// -- Begin XModelStream structures

struct GfxStreamVertex
{
	uint8_t Color[4];

	uint16_t UVUPosition;
	uint16_t UVVPosition;

	int32_t VertexNormal;
	int32_t VertexTangent;
};

struct GfxStreamWeight
{
	uint8_t WeightVal1;
	uint8_t WeightVal2;
	uint8_t WeightVal3;
	uint8_t WeightVal4;

	uint16_t WeightID1;
	uint16_t WeightID2;
	uint16_t WeightID3;
	uint16_t WeightID4;
};

struct GfxStreamFace
{
	uint16_t Index1;
	uint16_t Index2;
	uint16_t Index3;
};

// -- End XModelStream structures

// -- Black Ops 4 Pool Data Structure

struct BO4XAssetPoolData
{
	// The beginning of the pool
	uint64_t PoolPtr;

	// The size of the asset header
	uint32_t AssetSize;
	// The maximum pool size
	uint32_t PoolSize;

	// Padding
	uint32_t Padding;

	// The amount of assets in the pool
	uint32_t AssetsLoaded;

	// A pointer to the closest free header
	uint64_t PoolFreeHeadPtr;
};

// Verify that our pool data is exactly 0x20
static_assert(sizeof(BO4XAssetPoolData) == 0x20, "Invalid Pool Data Size (Expected 0x20)");

bool GameBlackOps4::LoadOffsets()
{
	// ----------------------------------------------------
	//	Black Ops 4 pools and sizes, XAssetPoolData is an array of pool info for each asset pool in the game
	//	The index of the assets we use are as follows: xanim (3), xmodel (4), ximage (0x9)
	//	Index * sizeof(BO4XAssetPoolData) = the offset of the asset info in this array of data, we can verify it using the xmodel pool and checking for the model hash (0x04647533e968c910)
	//  Notice: Black Ops 4 doesn't store a freePoolHandle at the beginning, so we just read on.
	//	On Black Ops 4, (0x04647533e968c910) will be the first xmodel
	//	Black Ops 4 stringtable, check entries, results may vary
	//	Reading is: (StringIndex * 16) + StringTablePtr + 16
	// ----------------------------------------------------

	// Attempt to load the game offsets
	if (CoDAssets::GameInstance != nullptr)
	{
		// We need the base address of the BO4 Module for ASLR + Heuristics
		auto BaseAddress = CoDAssets::GameInstance->GetMainModuleAddress();

		// Check built-in offsets via game exe mode (SP)
		for (auto& GameOffsets : SinglePlayerOffsets)
		{
			// Read required offsets (XANIM, XMODEL, XIMAGE, RAWFILE RELATED...)
			auto AnimPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(BaseAddress + GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 3));
			auto ModelPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(BaseAddress + GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 4));
			auto ImagePoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(BaseAddress + GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 0x9));

			// Apply game offset info
			CoDAssets::GameOffsetInfos.emplace_back(AnimPoolData.PoolPtr);
			CoDAssets::GameOffsetInfos.emplace_back(ModelPoolData.PoolPtr);
			CoDAssets::GameOffsetInfos.emplace_back(ImagePoolData.PoolPtr);

			// Verify via first xmodel asset, right now, we're using a hash
			auto FirstXModelHash = CoDAssets::GameInstance->Read<uint64_t>(CoDAssets::GameOffsetInfos[1]);
			// Check
			if (FirstXModelHash == 0x04647533e968c910)
			{
				// Validate sizes
				if (
					AnimPoolData.AssetSize == sizeof(BO4XAnim) &&
					ModelPoolData.AssetSize == sizeof(BO4XModel) &&
					ImagePoolData.AssetSize == sizeof(BO4GfxImage))
				{
					// Verify string table, otherwise we are all set
					CoDAssets::GameOffsetInfos.emplace_back(BaseAddress + GameOffsets.StringTable);
					// Read and apply sizes
					CoDAssets::GamePoolSizes.emplace_back(AnimPoolData.PoolSize);
					CoDAssets::GamePoolSizes.emplace_back(ModelPoolData.PoolSize);
					CoDAssets::GamePoolSizes.emplace_back(ImagePoolData.PoolSize);
					// Return success
					return true;
				}
			}
			// Reset
			CoDAssets::GameOffsetInfos.clear();
		}

		// In debug, print the info for easy additions later!
		#if _DEBUG
		// Attempt to locate via heuristic searching
		auto DBAssetsScan = CoDAssets::GameInstance->Scan("48 89 5C 24 ?? 57 48 83 EC ?? 0F B6 F9 48 8D 05 ?? ?? ?? ??");
		auto StringTableScan = CoDAssets::GameInstance->Scan("48 8B 53 ?? 48 85 D2 74 ?? 48 8B 03 48 89 02");

		// Load info and verify
		auto GameOffsets = DBGameInfo(
			// Resolve pool info from LEA
			CoDAssets::GameInstance->Read<uint32_t>(DBAssetsScan + 0x10) + (DBAssetsScan + 0x14),
			// We don't use size offsets
			0,
			// Resolve strings from LEA
			CoDAssets::GameInstance->Read<uint32_t>(StringTableScan + 0x12) + (StringTableScan + 0x16),
			// We don't use package offsets
			0
		);
		
		// Format the output
		printf("Heuristic: { 0x%X, 0x0, 0x%X, 0x0 }\n", (GameOffsets.DBAssetPools - BaseAddress), (GameOffsets.StringTable - BaseAddress));
		#endif

		// All Bo4 Updates require a tool update

//		// Check that we had hits
//		if (DBAssetsScan > 0 && StringTableScan > 0)
//		{
//			// Load info and verify
//			auto GameOffsets = DBGameInfo(
//				// Resolve pool info from LEA
//				CoDAssets::GameInstance->Read<uint32_t>(DBAssetsScan + 0x10) + (DBAssetsScan + 0x14),
//				// We don't use size offsets
//				0,
//				// Resolve strings from LEA
//				CoDAssets::GameInstance->Read<uint32_t>(StringTableScan + 0x12) + (StringTableScan + 0x16),
//				// We don't use package offsets
//				0
//			);
//
//			// In debug, print the info for easy additions later!
//#if _DEBUG
//			// Format the output
//			printf("Heuristic: { 0x%X, 0x0, 0x%X, 0x0 }\n", (GameOffsets.DBAssetPools - BaseAddress), (GameOffsets.StringTable - BaseAddress));
//#endif
//
//
//			// Read required offsets (XANIM, XMODEL, XIMAGE)
//			auto AnimPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 3));
//			auto ModelPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 4));
//			auto ImagePoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 0x9));
//
//			// Apply game offset info
//			CoDAssets::GameOffsetInfos.emplace_back(AnimPoolData.PoolPtr);
//			CoDAssets::GameOffsetInfos.emplace_back(ModelPoolData.PoolPtr);
//			CoDAssets::GameOffsetInfos.emplace_back(ImagePoolData.PoolPtr);
//
//			// Verify via first xmodel asset, right now, we're using a hash
//			auto FirstXModelHash = CoDAssets::GameInstance->Read<uint64_t>(CoDAssets::GameOffsetInfos[1]);
//
//			// Check
//			if (FirstXModelHash == 0x04647533e968c910)
//			{
//				// Validate sizes
//				if (
//					AnimPoolData.AssetSize  == sizeof(BO4XAnim) && 
//					ModelPoolData.AssetSize == sizeof(BO4XModel) && 
//					ImagePoolData.AssetSize == sizeof(BO4GfxImage))
//				{
//					// Verify string table, otherwise we are all set
//					CoDAssets::GameOffsetInfos.emplace_back(GameOffsets.StringTable);
//
//					// Read and apply sizes
//					CoDAssets::GamePoolSizes.emplace_back(AnimPoolData.PoolSize);
//					CoDAssets::GamePoolSizes.emplace_back(ModelPoolData.PoolSize);
//					CoDAssets::GamePoolSizes.emplace_back(ImagePoolData.PoolSize);
//
//					// Return success
//					return true;
//				}
//			}
//		}
	}

	// Failed
	return false;
}

bool GameBlackOps4::LoadAssets()
{
	// Prepare to load game assets, into the AssetPool
	bool NeedsAnims = (SettingsManager::GetSetting("showxanim", "true") == "true");
	bool NeedsModels = (SettingsManager::GetSetting("showxmodel", "true") == "true");
	bool NeedsImages = (SettingsManager::GetSetting("showximage", "false") == "true");
	bool NeedsRawFiles = (SettingsManager::GetSetting("showxrawfiles", "false") == "true");

	/*
		This was implemented as a fix for a specific user who requested it, as the search box is capped at 32767 by Windows
		and this is a workaround, if you're interested in using it, any hashes in this filters file will be ignored on load,
		essentially acting as an excluder, consider it a hidden feature with no support as it was made for a specific use
		case. If you cannot get it to work, do not ask me.
	*/
	auto Filters = WraithNameIndex();
	Filters.LoadIndex("package_index\\bo4_filters.wni");

	// Check if we need assets
	if (NeedsAnims)
	{
		// Parse the XAnim pool
		CoDXPoolParser<uint64_t, BO4XAnim>((CoDAssets::GameOffsetInfos[0]), CoDAssets::GamePoolSizes[0], [Filters](BO4XAnim& Asset, uint64_t& AssetOffset)
		{
			// Mask the name as hashes are 60Bit
			Asset.NamePtr &= 0xFFFFFFFFFFFFFFF;

			// Check for filters
			if (Filters.NameDatabase.size() > 0)
			{
				// Check for this asset in DB
				if (Filters.NameDatabase.find(Asset.NamePtr) != Filters.NameDatabase.end())
				{
					// Skip this asset
					return;
				}
			}

			// Validate and load if need be
			auto AnimName = Strings::Format("xanim_%llx", Asset.NamePtr);

			// Check for an override in the name DB
			if (AssetNameCache.NameDatabase.find(Asset.NamePtr) != AssetNameCache.NameDatabase.end())
				AnimName = AssetNameCache.NameDatabase[Asset.NamePtr];

			// Make and add
			auto LoadedAnim = new CoDAnim_t();
			// Set
			LoadedAnim->AssetName = AnimName;
			LoadedAnim->AssetPointer = AssetOffset;
			LoadedAnim->Framerate = Asset.Framerate;
			LoadedAnim->FrameCount = Asset.NumFrames;
			LoadedAnim->AssetStatus = WraithAssetStatus::Loaded;
			// Add
			CoDAssets::GameAssets->LoadedAssets.push_back(LoadedAnim);
		});
	}

	if (NeedsModels)
	{
		// Parse the XModel pool
		CoDXPoolParser<uint64_t, BO4XModel>((CoDAssets::GameOffsetInfos[1]), CoDAssets::GamePoolSizes[1], [Filters](BO4XModel& Asset, uint64_t& AssetOffset)
		{
			// Mask the name as hashes are 60Bit
			Asset.NamePtr &= 0xFFFFFFFFFFFFFFF;

			// Check for filters
			if (Filters.NameDatabase.size() > 0)
			{
				// Check for this asset in DB
				if (Filters.NameDatabase.find(Asset.NamePtr) != Filters.NameDatabase.end())
				{
					// Skip this asset
					return;
				}
			}

			// Validate and load if need be
			auto ModelName = Strings::Format("xmodel_%llx", Asset.NamePtr);

			// Check for an override in the name DB
			if (AssetNameCache.NameDatabase.find(Asset.NamePtr) != AssetNameCache.NameDatabase.end())
				ModelName = AssetNameCache.NameDatabase[Asset.NamePtr];

			// Make and add
			auto LoadedModel = new CoDModel_t();
			// Set
			LoadedModel->AssetName = ModelName;
			LoadedModel->AssetPointer = AssetOffset;
			LoadedModel->BoneCount = (Asset.NumBones + Asset.NumCosmeticBones);
			LoadedModel->LodCount = Asset.NumLods;
			LoadedModel->AssetStatus = WraithAssetStatus::Loaded;
			// Add
			CoDAssets::GameAssets->LoadedAssets.push_back(LoadedModel);
		});
	}

	if (NeedsImages)
	{
		// Parse the XModel pool
		CoDXPoolParser<uint64_t, BO4GfxImage>((CoDAssets::GameOffsetInfos[2]), CoDAssets::GamePoolSizes[2], [Filters](BO4GfxImage& Asset, uint64_t& AssetOffset)
		{
			// Mask the name as hashes are 60Bit
			Asset.NamePtr &= 0xFFFFFFFFFFFFFFF;

			// Check for filters
			if (Filters.NameDatabase.size() > 0)
			{
				// Check for this asset in DB
				if (Filters.NameDatabase.find(Asset.NamePtr) != Filters.NameDatabase.end())
				{
					// Skip this asset
					return;
				}
			}

			// Validate and load if need be
			auto ImageName = Strings::Format("ximage_%llx", Asset.NamePtr);

			// Check for an override in the name DB
			if (AssetNameCache.NameDatabase.find(Asset.NamePtr) != AssetNameCache.NameDatabase.end())
				ImageName = AssetNameCache.NameDatabase[Asset.NamePtr];

			// Check for loaded images
			// if (Asset.GfxMipsPtr != 0)
			{
				// Make and add
				auto LoadedImage = new CoDImage_t();
				// Set
				LoadedImage->AssetName = ImageName;
				LoadedImage->AssetPointer = AssetOffset;
				LoadedImage->Width = (uint16_t)Asset.LoadedMipWidth;
				LoadedImage->Height = (uint16_t)Asset.LoadedMipHeight;
				LoadedImage->Format = (uint16_t)Asset.ImageFormat;
				LoadedImage->AssetStatus = WraithAssetStatus::Loaded;
				// Add
				CoDAssets::GameAssets->LoadedAssets.push_back(LoadedImage);
			}
		});
	}

	// Success, error only on specific load
	return true;
}

std::unique_ptr<XAnim_t> GameBlackOps4::ReadXAnim(const CoDAnim_t* Animation)
{
	// Verify that the program is running
	if (CoDAssets::GameInstance->IsRunning())
	{
		// Prepare to read the xanim
		auto Anim = std::make_unique<XAnim_t>();

		// Read the XAnim structure
		auto AnimData = CoDAssets::GameInstance->Read<BO4XAnim>(Animation->AssetPointer);

		// Copy over default properties
		Anim->AnimationName = Animation->AssetName;
		// Frames and Rate
		Anim->FrameCount = AnimData.NumFrames;
		Anim->FrameRate = AnimData.Framerate;

		// Check for viewmodel animations
		if ((_strnicmp(Animation->AssetName.c_str(), "viewmodel_", 10) == 0) || (_strnicmp(Animation->AssetName.c_str(), "vm_", 3) == 0))
		{
			// This is a viewmodel animation
			Anim->ViewModelAnimation = true;
		}
		////// Check for additive animations
		////if (AnimData.AssetType == 0x6)
		////{
		////	// This is a additive animation
		////	Anim->AdditiveAnimation = true;
		////}
		////// Check for looping
		////Anim->LoopingAnimation = (AnimData.LoopingFlag > 0);

		// Read the delta data
		auto AnimDeltaData = CoDAssets::GameInstance->Read<BO4XAnimDeltaParts>(AnimData.DeltaPartsPtr);

		// Copy over pointers
		Anim->BoneIDsPtr = AnimData.BoneIDsPtr;
		Anim->DataBytesPtr = AnimData.DataBytePtr;
		Anim->DataShortsPtr = AnimData.DataShortPtr;
		Anim->DataIntsPtr = AnimData.DataIntPtr;
		Anim->RandomDataBytesPtr = AnimData.RandomDataBytePtr;
		Anim->RandomDataShortsPtr = AnimData.RandomDataShortPtr;
		Anim->NotificationsPtr = AnimData.NotificationsPtr;

		// Bone ID index size
		Anim->BoneIndexSize = 4;

		// Copy over counts
		Anim->NoneRotatedBoneCount = AnimData.NoneRotatedBoneCount;
		Anim->TwoDRotatedBoneCount = AnimData.TwoDRotatedBoneCount;
		Anim->NormalRotatedBoneCount = AnimData.NormalRotatedBoneCount;
		Anim->TwoDStaticRotatedBoneCount = AnimData.TwoDStaticRotatedBoneCount;
		Anim->NormalStaticRotatedBoneCount = AnimData.NormalStaticRotatedBoneCount;
		Anim->NormalTranslatedBoneCount = AnimData.NormalTranslatedBoneCount;
		Anim->PreciseTranslatedBoneCount = AnimData.PreciseTranslatedBoneCount;
		Anim->StaticTranslatedBoneCount = AnimData.StaticTranslatedBoneCount;
		Anim->NoneTranslatedBoneCount = AnimData.NoneTranslatedBoneCount;
		Anim->TotalBoneCount = AnimData.TotalBoneCount;
		Anim->NotificationCount = AnimData.NotificationCount;

		// Copy delta
		Anim->DeltaTranslationPtr = AnimDeltaData.DeltaTranslationsPtr;
		Anim->Delta2DRotationsPtr = AnimDeltaData.Delta2DRotationsPtr;
		Anim->Delta3DRotationsPtr = AnimDeltaData.Delta3DRotationsPtr;

		// Set types, we use quata for BO4
		Anim->RotationType = AnimationKeyTypes::QuatPackingA;
		Anim->TranslationType = AnimationKeyTypes::MinSizeTable;

		// Black Ops 4 doesn't support inline indicies
		Anim->SupportsInlineIndicies = false;

		// Return it
		return Anim;
	}
	// Not running
	return nullptr;
}

std::unique_ptr<XModel_t> GameBlackOps4::ReadXModel(const CoDModel_t* Model)
{
	// Verify that the program is running
	if (CoDAssets::GameInstance->IsRunning())
	{
		// Read the XModel structure
		auto ModelData = CoDAssets::GameInstance->Read<BO4XModel>(Model->AssetPointer);

		// Prepare to read the xmodel (Reserving space for lods)
		auto ModelAsset = std::make_unique<XModel_t>(ModelData.NumLods);

		// Copy over default properties
		ModelAsset->ModelName = Model->AssetName;
		// Bone counts
		ModelAsset->BoneCount = ModelData.NumBones;
		ModelAsset->RootBoneCount = ModelData.NumRootBones;
		ModelAsset->CosmeticBoneCount = ModelData.NumCosmeticBones;

		// Bone data type
		ModelAsset->BoneRotationData = BoneDataTypes::QuatPackingA;

		// We are streamed
		ModelAsset->IsModelStreamed = true;

		// Bone id info
		ModelAsset->BoneIDsPtr = ModelData.BoneIDsPtr;
		ModelAsset->BoneIndexSize = 4;

		// Bone parent info
		ModelAsset->BoneParentsPtr = ModelData.ParentListPtr;
		ModelAsset->BoneParentSize = 1;

		// Local bone pointers
		ModelAsset->RotationsPtr = ModelData.RotationsPtr;
		ModelAsset->TranslationsPtr = ModelData.TranslationsPtr;

		// Global matricies
		ModelAsset->BaseMatriciesPtr = ModelData.BaseMatriciesPtr;

		// Prepare to parse lods
		for (uint32_t i = 0; i < ModelData.NumLods; i++)
		{
			// Read the lod
			auto LODInfo = CoDAssets::GameInstance->Read<BO4XModelLod>(ModelData.ModelLodPtrs[i]);
			// Create the lod and grab reference
			ModelAsset->ModelLods.emplace_back(LODInfo.NumSurfs);
			// Grab reference
			auto& LodReference = ModelAsset->ModelLods[i];

			// Set distance
			LodReference.LodDistance = LODInfo.LodDistance;

			// Set stream key and info ptr
			LodReference.LODStreamKey = LODInfo.LODStreamKey;
			LodReference.LODStreamInfoPtr = LODInfo.XModelMeshPtr;

			// Grab pointer from the lod itself
			auto XSurfacePtr = LODInfo.XSurfacePtr;

			// Skip 8 bytes in materials
			ModelData.MaterialHandlesPtr += 8;
			// Read material handles ptr
			auto MaterialHandlesPtr = CoDAssets::GameInstance->Read<uint64_t>(ModelData.MaterialHandlesPtr);
			// Advance 8 and skip 16 bytes
			ModelData.MaterialHandlesPtr += 0x10;

			// Load surfaces
			for (uint32_t s = 0; s < LODInfo.NumSurfs; s++)
			{
				// Create the surface and grab reference
				LodReference.Submeshes.emplace_back();
				// Grab reference
				auto& SubmeshReference = LodReference.Submeshes[s];

				// Read the surface data
				auto SurfaceInfo = CoDAssets::GameInstance->Read<BO4XModelSurface>(XSurfacePtr);
				// Apply surface info
				SubmeshReference.VertexCount = SurfaceInfo.VertexCount;
				SubmeshReference.FaceCount = SurfaceInfo.FacesCount;
				SubmeshReference.VertexPtr = SurfaceInfo.VerticiesIndex;
				SubmeshReference.FacesPtr = SurfaceInfo.FacesIndex;

				// Assign weight info to the count slots, to save memory
				SubmeshReference.WeightCounts[0] = SurfaceInfo.Flag1;
				SubmeshReference.WeightCounts[1] = SurfaceInfo.Flag2;
				SubmeshReference.WeightCounts[2] = SurfaceInfo.Flag3;
				SubmeshReference.WeightCounts[3] = SurfaceInfo.Flag4;

				// Read this submesh's material handle
				auto MaterialHandle = CoDAssets::GameInstance->Read<uint64_t>(MaterialHandlesPtr);
				// Create the material and add it
				LodReference.Materials.emplace_back(ReadXMaterial(MaterialHandle));

				// Advance
				XSurfacePtr += sizeof(BO4XModelSurface);
				MaterialHandlesPtr += sizeof(uint64_t);
			}
		}

		// Return it
		return ModelAsset;
	}
	// Not running
	return nullptr;
}

std::unique_ptr<XImageDDS> GameBlackOps4::ReadXImage(const CoDImage_t* Image)
{
	// Proxy off
	return LoadXImage(XImage_t(ImageUsageType::DiffuseMap, 0, Image->AssetPointer, Image->AssetName));
}

const XMaterial_t GameBlackOps4::ReadXMaterial(uint64_t MaterialPointer)
{
	// Prepare to parse the material
	auto MaterialData = CoDAssets::GameInstance->Read<BO4XMaterial>(MaterialPointer);

	// Mask the name (some bits are used for other stuffs)
	MaterialData.Hash &= 0xFFFFFFFFFFFFFFF;
	// Allocate a new material with the given image count
	XMaterial_t Result(MaterialData.ImageCount);
	// Clean the name, then apply it
	Result.MaterialName = Strings::Format("xmaterial_%llx", MaterialData.Hash);

	// Check for an override in the name DB
	if (AssetNameCache.NameDatabase.find(MaterialData.Hash) != AssetNameCache.NameDatabase.end())
		Result.MaterialName = AssetNameCache.NameDatabase[MaterialData.Hash];

	// Iterate over material images, assign proper references if available
	for (uint32_t m = 0; m < MaterialData.ImageCount; m++)
	{
		// Read the image info
		auto ImageInfo = CoDAssets::GameInstance->Read<BO4XMaterialImage>(MaterialData.ImageTablePtr);

		// Get Hash and mask it (some bits are used for other stuffs)
		auto ImageHash = CoDAssets::GameInstance->Read<uint64_t>(ImageInfo.ImagePtr + 0x20) & 0xFFFFFFFFFFFFFFF;

		// Get the image name
		auto ImageName = Strings::Format("ximage_%llx", ImageHash);

		// Check for an override in the name DB
		if (AssetNameCache.NameDatabase.find(ImageHash) != AssetNameCache.NameDatabase.end())
			ImageName = AssetNameCache.NameDatabase[ImageHash];

		// Default type
		auto DefaultUsage = ImageUsageType::Unknown;
		// Check 
		switch (ImageInfo.SemanticHash)
		{
		case 0xA0AB1041:
			DefaultUsage = ImageUsageType::DiffuseMap;
			break;
		case 0x59D30D0F:
			DefaultUsage = ImageUsageType::NormalMap;
			break;
		case 0xEC443804:
			DefaultUsage = ImageUsageType::SpecularMap;
			break;
		}

		// Assign the new image
		Result.Images.emplace_back(DefaultUsage, ImageInfo.SemanticHash, ImageInfo.ImagePtr, ImageName);

		// Advance
		MaterialData.ImageTablePtr += sizeof(BO4XMaterialImage);
	}

	// Return it
	return Result;
}

std::unique_ptr<XImageDDS> GameBlackOps4::LoadXImage(const XImage_t& Image)
{
	// Prepare to load an image, we need to rip loaded and streamed ones
	uint32_t ResultSize = 0;

	// We must read the image data
	auto ImageInfo = CoDAssets::GameInstance->Read<BO4GfxImage>(Image.ImagePtr);

	// Calculate the largest image mip
	uint32_t LargestMip = 0;
	uint32_t LargestWidth = 0;
	uint32_t LargestHeight = 0;
	uint64_t LargestHash = 0;

	// Loop and calculate
	for (uint32_t i = 0; i < ImageInfo.GfxMipMaps; i++)
	{
		// Load Mip Map
		auto MipMap = CoDAssets::GameInstance->Read<BO4GfxMip>(ImageInfo.GfxMipsPtr);
		// Compare widths
		if (MipMap.Width > LargestWidth)
		{
			LargestMip = i;
			LargestWidth = MipMap.Width;
			LargestHeight = MipMap.Height;
			LargestHash = MipMap.HashID;
		}
		// Advance Mip Map Pointer
		ImageInfo.GfxMipsPtr += sizeof(BO4GfxMip);
	}

	// Calculate proper image format (Convert signed to unsigned)
	switch (ImageInfo.ImageFormat)
	{
		// Fix invalid BC1_SRGB images, swap to BC1_UNORM
	case 72: ImageInfo.ImageFormat = 71; break;
		// Fix invalid BC2_SRGB images, swap to BC2_UNORM
	case 75: ImageInfo.ImageFormat = 74; break;
		// Fix invalid BC3_SRGB images, swap to BC3_UNORM
	case 78: ImageInfo.ImageFormat = 77; break;
		// Fix invalid BC7_SRGB images, swap to BC7_UNORM
	case 99: ImageInfo.ImageFormat = 98; break;
	}

	// Buffer
	std::unique_ptr<uint8_t[]> ImageData = nullptr;

	// Check if we're missing a hash / size
	if (LargestWidth == 0 || LargestHash == 0)
	{
		// Set sizes
		LargestWidth = ImageInfo.LoadedMipWidth;
		LargestHeight = ImageInfo.LoadedMipHeight;

		// Temporary size
		uintptr_t ImageMemoryResult = 0;
		// We have a loaded image, prepare to dump from memory
		auto ImageMemoryBuffer = CoDAssets::GameInstance->Read(ImageInfo.LoadedMipPtr, ImageInfo.LoadedMipSize, ImageMemoryResult);

		// Make sure we got it
		if (ImageMemoryBuffer != nullptr)
		{
			// Allocate a safe block
			ImageData = std::make_unique<uint8_t[]>((uint32_t)ImageMemoryResult);
			// Copy data over
			std::memcpy(ImageData.get(), ImageMemoryBuffer, ImageMemoryResult);

			// Set size
			ResultSize = (uint32_t)ImageMemoryResult;

			// Clean up
			delete[] ImageMemoryBuffer;
		}
	}
	else
	{
		// We have a streamed image, prepare to extract
		ImageData = CoDAssets::GamePackageCache->ExtractPackageObject(LargestHash, ResultSize);
	}

	// Prepare if we have it
	if (ImageData != nullptr)
	{
		// Prepare to create a MemoryDDS file
		auto Result = CoDRawImageTranslator::TranslateBC(ImageData, ResultSize, LargestWidth, LargestHeight, ImageInfo.ImageFormat);

		// Check for, and apply patch if required, if we got a raw result
		if (Result != nullptr && Image.ImageUsage == ImageUsageType::NormalMap && (SettingsManager::GetSetting("patchnormals", "true") == "true"))
		{
			// Set normal map patch
			Result->ImagePatchType = ImagePatch::Normal_Expand;
		}

		// Return it
		return Result;
	}

	// Failed to load the image
	return nullptr;
}

void GameBlackOps4::LoadXModel(const XModelLod_t& ModelLOD, const std::unique_ptr<WraithModel>& ResultModel)
{
	// Check if we want Vertex Colors
	bool ExportColors = (SettingsManager::GetSetting("exportvtxcolor", "true") == "true");
	// Read the mesh information
	auto MeshInfo = CoDAssets::GameInstance->Read<BO4XModelMeshInfo>(ModelLOD.LODStreamInfoPtr);

	// A buffer for the mesh data
	std::unique_ptr<uint8_t[]> MeshDataBuffer = nullptr;
	// Resulting size
	uint64_t MeshDataBufferSize = 0;

	// Vertex has extended vertex information
	bool HasExtendedVertexInfo = (MeshInfo.StatusFlag & 64) != 0;

	// Determine if we need to load the mesh or not (Seems flag == 8 is loaded)
	if ((MeshInfo.StatusFlag & 0x3F) == 8)
	{
		// Result size
		uintptr_t ResultSize = 0;
		// The mesh is already loaded, just read it
		auto TemporaryBuffer = CoDAssets::GameInstance->Read(MeshInfo.XModelMeshBufferPtr, MeshInfo.XModelMeshBufferSize, ResultSize);

		// Copy and clean up
		if (TemporaryBuffer != nullptr)
		{
			// Allocate safe
			MeshDataBuffer = std::make_unique<uint8_t[]>(MeshInfo.XModelMeshBufferSize);
			// Copy over
			std::memcpy(MeshDataBuffer.get(), TemporaryBuffer, (size_t)ResultSize);
			// Set size
			MeshDataBufferSize = ResultSize;

			// Clean up
			delete[] TemporaryBuffer;
		}
	}
	else
	{
		// Result size
		uint32_t ResultSize = 0;
		// We must read from the cache
		MeshDataBuffer = CoDAssets::GamePackageCache->ExtractPackageObject(ModelLOD.LODStreamKey, ResultSize);
		// Set size
		MeshDataBufferSize = ResultSize;
	}

	// Continue on success
	if (MeshDataBuffer != nullptr)
	{
		// Make a reader to begin reading the mesh (Don't close)
		auto MeshReader = MemoryReader((int8_t*)MeshDataBuffer.get(), MeshDataBufferSize, true);

		// The total weighted verticies
		uint32_t TotalReadWeights = 0;
		// The maximum weight index
		uint32_t MaximumWeightIndex = ResultModel->BoneCount() - 1;

		// Prepare it for submeshes
		ResultModel->PrepareSubmeshes((uint32_t)ModelLOD.Submeshes.size());

		// Iterate over submeshes
		for (auto& Submesh : ModelLOD.Submeshes)
		{
			// Create and grab a new submesh
			auto& Mesh = ResultModel->AddSubmesh();

			// Set the material (COD has 1 per submesh)
			Mesh.AddMaterial(Submesh.MaterialIndex);

			// Prepare the mesh for the data
			Mesh.PrepareMesh(Submesh.VertexCount, Submesh.FaceCount);

			// Jump to vertex position data, advance to this submeshes verticies
			MeshReader.SetPosition(MeshInfo.VertexOffset + (Submesh.VertexPtr * 12));

			// Iterate over verticies
			for (uint32_t i = 0; i < Submesh.VertexCount; i++)
			{
				// Make a new vertex
				auto& Vertex = Mesh.AddVertex();

				// Read and assign position
				Vertex.Position = MeshReader.Read<Vector3>();
			}

			// Jump to vertex info data, advance to this submeshes info, seek further for extended vertex info
			MeshReader.SetPosition(MeshInfo.UVOffset + (Submesh.VertexPtr * (HasExtendedVertexInfo ? 24 : 16)));

			// Iterate over verticies
			for (uint32_t i = 0; i < Submesh.VertexCount; i++)
			{
				// Grab the reference
				auto& Vertex = Mesh.Verticies[i];

				// Read vertex data
				auto VertexData = MeshReader.Read<GfxStreamVertex>();

				// Add UV layer
				Vertex.AddUVLayer(HalfFloats::ToFloat(VertexData.UVUPosition), HalfFloats::ToFloat(VertexData.UVVPosition));

				// Unpack normal
				int32_t PackedX = (((VertexData.VertexNormal >> 0) & ((1 << 10) - 1)) - 512);
				int32_t PackedY = (((VertexData.VertexNormal >> 10) & ((1 << 10) - 1)) - 512);
				int32_t PackedZ = (((VertexData.VertexNormal >> 20) & ((1 << 10) - 1)) - 512);
				// Calculate
				Vertex.Normal.X = ((float)PackedX / 511.0f);
				Vertex.Normal.Y = ((float)PackedY / 511.0f);
				Vertex.Normal.Z = ((float)PackedZ / 511.0f);

				// Add Colors if we want them
				if (ExportColors)
				{
					Vertex.Color[0] = VertexData.Color[0];
					Vertex.Color[1] = VertexData.Color[1];
					Vertex.Color[2] = VertexData.Color[2];
					Vertex.Color[3] = VertexData.Color[3];
				}
				else
				{
					Vertex.Color[0] = 0xFF;
					Vertex.Color[1] = 0xFF;
					Vertex.Color[2] = 0xFF;
					Vertex.Color[3] = 0xFF;
				}

				// Skip extended vertex information (first 4 bytes seems to be UV, possibly for better camo UV Mapping)
				if (HasExtendedVertexInfo)
					MeshReader.Advance(8);
			}

			// Jump to vertex weight data, advance to this submeshes info
			MeshReader.SetPosition(MeshInfo.WeightsOffset + (Submesh.VertexPtr * 12));

			// Iterate over verticies
			for (uint32_t i = 0; i < Submesh.VertexCount; i++)
			{
				// Grab the reference
				auto& Vertex = Mesh.Verticies[i];
				
				// Check if we're a complex weight, up to four weights
				if (((uint8_t)Submesh.WeightCounts[0] & 2) > 0)
				{
					// Read weight data
					auto VertexWeight = MeshReader.Read<GfxStreamWeight>();

					// Add if need be
					Vertex.AddVertexWeight(VertexWeight.WeightID1, (VertexWeight.WeightVal1 / 255.0f));
					// Calculate max
					MaximumWeightIndex = std::max<uint32_t>(VertexWeight.WeightID1, MaximumWeightIndex);

					// Check for value 2
					if (VertexWeight.WeightVal2 > 0)
					{
						Vertex.AddVertexWeight(VertexWeight.WeightID2, (VertexWeight.WeightVal2 / 255.0f));
						// Calculate max
						MaximumWeightIndex = std::max<uint32_t>(VertexWeight.WeightID2, MaximumWeightIndex);
					}

					// Check for value 3
					if (VertexWeight.WeightVal3 > 0)
					{
						Vertex.AddVertexWeight(VertexWeight.WeightID3, (VertexWeight.WeightVal3 / 255.0f));
						// Calculate max
						MaximumWeightIndex = std::max<uint32_t>(VertexWeight.WeightID3, MaximumWeightIndex);
					}

					// Check for value 4
					if (VertexWeight.WeightVal4 > 0)
					{
						Vertex.AddVertexWeight(VertexWeight.WeightID4, (VertexWeight.WeightVal4 / 255.0f));
						// Calculate max
						MaximumWeightIndex = std::max<uint32_t>(VertexWeight.WeightID4, MaximumWeightIndex);
					}

					// Increase
					TotalReadWeights++;
				}
				else
				{
					// Simple weight
					Vertex.AddVertexWeight(0, 1.0);
				}

			}

			// Jump to face data, advance to this submeshes faces
			MeshReader.SetPosition(MeshInfo.FacesOffset + (Submesh.FacesPtr * 2));

			// Iterate over faces
			for (uint32_t i = 0; i < Submesh.FaceCount; i++)
			{
				// Read data
				auto Face = MeshReader.Read<GfxStreamFace>();

				// Add the face
				Mesh.AddFace(Face.Index1, Face.Index2, Face.Index3);
			}
		}

		// Prepare to generate stream bones if we had a conflict
		if (MaximumWeightIndex > (ResultModel->BoneCount() - 1))
		{
			// Generate stream bones
			auto CurrentBoneCount = ResultModel->BoneCount();
			auto WantedBoneCount = (MaximumWeightIndex + 1);

			// Loop and create
			for (uint32_t i = 0; i < (WantedBoneCount - CurrentBoneCount); i++)
			{
				auto& StreamBone = ResultModel->AddBone();

				// Set name and parent
				StreamBone.TagName = Strings::Format("smod_bone%d", i);
				StreamBone.BoneParent = 0;
			}

			// Ensure root is tag_origin
			ResultModel->Bones[0].TagName = "tag_origin";
		}
	}
}

std::string GameBlackOps4::DecryptString(uint8_t* InputBuffer, uint8_t InputLength, uint8_t EncryptionID, uint64_t StringHash)
{
	switch ((uint8_t)(EncryptionID + 128))
	{
	case 3:
	{
		// Start values
		uint32_t k = 9972;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k -= DecryptionTable[(uint8_t)k + ((i & 0xF) << 8)];
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k - 12;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 4:
	{
		// Start values
		uint32_t k = 7150;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k ^= DecryptionTable[(k % 0xC8) + ((i & 7) << 8)];
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = -18 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 5:
	{
		// Start values
		uint32_t k = 9725;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k += i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k ^ 0xFD;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 6:
	{
		// Start values
		uint32_t k = 6328;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k ^ 0xB8;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 7:
	{
		// Start values
		uint32_t k = 334;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k * 78;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 8:
	{
		// Start values
		uint32_t k = 163;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k += DecryptionTable[(k % 0x3C) + ((i % 0xCU) << 8)];
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = -93 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 9:
	{
		// Start values
		uint32_t k = 381;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Edit key
			j = k + 125;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 10:
	{
		// Start values
		uint32_t k = 479;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k ^ 0xDF;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 11:
	{
		// Start values
		uint32_t k = 9185;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = -31 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 12:
	{
		// Start values
		uint32_t k = 6998;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k += DecryptionTable[(uint8_t)k + ((k & 0xF) << 8)];
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k + 86;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 13:
	{
		// Start values
		uint32_t k = 8602;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k - 102;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 14:
	{
		// Start values
		uint32_t k = 1193;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k ^ 0xA9;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 15:
	{
		// Start values
		uint32_t k = 3791;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = -49 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 33:
	{
		// Start values
		uint32_t k = 6299;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k *= DecryptionTable[(k % 0xE8) + ((i % 0xC) << 8)];
			// Edit key
			j = -101 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 34:
	{
		// Start values
		uint32_t k = 6463;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k ^ 0x3F;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 35:
	{
		// Start values
		uint32_t k = 2058;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Edit key
			j = k + 10;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 36:
	{
		// Start values
		uint32_t k = 4011;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = -85 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 37:
	{
		// Start values
		uint32_t k = 8783;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = 79 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 38:
	{
		// Start values
		uint32_t k = 7712;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k * 32;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 39:
	{
		// Start values
		uint32_t k = 7851;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k += i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k - 85;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 40:
	{
		// Start values
		uint32_t k = 2719;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Edit key
			j = k - 97;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 41:
	{
		// Start values
		uint32_t k = 558;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k *= DecryptionTable[i + ((k % 9) << 8)];
			// Edit key
			j = k ^ 0x2E;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 42:
	{
		// Start values
		uint32_t k = 3621;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k * 37;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 43:
	{
		// Start values
		uint32_t k = 4706;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k ^ 0x62;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 44:
	{
		// Start values
		uint32_t k = 8062;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k += i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = 126 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 45:
	{
		// Start values
		uint32_t k = 2375;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Edit key
			j = 71 + k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 46:
	{
		// Start values
		uint32_t k = 6568;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k ^ 0xA8;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 47:
	{
		// Start values
		uint32_t k = 3487;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k += DecryptionTable[(uint8_t)k + ((i & 0xF) << 8)];
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = -97 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 49:
	{
		// Start values
		uint32_t k = 3815;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Edit key
			j = -25 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 50:
	{
		// Start values
		uint32_t k = 3226;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k - 102;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 51:
	{
		// Start values
		uint32_t k = 4097;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k += i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k + 1;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 52:
	{
		// Start values
		uint32_t k = 4032;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Edit key
			j = -64 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 53:
	{
		// Start values
		uint32_t k = 2736;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k *= DecryptionTable[(i & 0x1F) + ((i & 0xF) << 8)];
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = -80 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 54:
	{
		// Start values
		uint32_t k = 3990;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k *= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = -106 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 55:
	{
		// Start values
		uint32_t k = 5325;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Edit key
			j = k - 51;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 56:
	{
		// Start values
		uint32_t k = 8971;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k += i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k ^ 0xB;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 57:
	{
		// Start values
		uint32_t k = -93;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Edit key
			j = -93 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 58:
	{
		// Start values
		uint32_t k = 8679;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k ^= DecryptionTable[i + ((k % 0xD) << 8)];
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = k ^ 0xE7;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 59:
	{
		// Start values
		uint32_t k = 2460;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k += i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = -100 - k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 60:
	{
		// Start values
		uint32_t k = 6917;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k -= i;
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k + 5;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 61:
	{
		// Start values
		uint32_t k = 7260;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Edit values
			k ^= i;
			// Rotate it
			InputBuffer[i] = RotateRight8(InputBuffer[i], k);
			// Edit key
			j = 92 * k;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 62:
	{
		// Start values
		uint32_t k = 1810;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k ^= DecryptionTable[(uint8_t)k + ((k & 0xF) << 8)];
			// Edit key
			j = k ^ 0x12;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	case 63:
	{
		// Start values
		uint32_t k = 660;
		uint8_t j = 0;
		// Loop through bytes
		for (uint8_t i = 0; i < InputLength - 1; i++)
		{
			// Read from the internal int32 array
			k *= DecryptionTable[(uint8_t)k + ((k & 0xF) << 8)];
			// Rotate it
			InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
			// Edit key
			j = k - 64;
			// Decrypt it if the key and input differ
			InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
		}
		// Done
		break;
	}
	default:
		break;
	}
#if _DEBUG
	// Validate strings in debug to check for encryption changes
	uint64_t Hash = 0xCBF29CE484222325;
	// Loop through string
	for (uint8_t i = 0; i < InputLength; i++)
		Hash = 0x100000001B3 * (InputBuffer[i] ^ Hash);
	// Check it against input
	if (Hash != StringHash)
		printf("Hash check failed: ID %#X - Input Hash 0x%llX - Hash Result 0x%llX - %s - Size %i\n", EncryptionID, StringHash, Hash, InputBuffer, InputLength);
#endif
	// Done
	return std::string(reinterpret_cast<char const*>(InputBuffer), InputLength - 1);
}

std::string GameBlackOps4::LoadStringEntry(uint64_t Index)
{
	// Calculate Offset to String (Offsets[3] = StringTable)
	auto Offset = CoDAssets::GameOffsetInfos[3] + (Index * 20);
	// Read Result
	uint64_t BytesRead = 0;
	// Read Info
	auto StringHash      = CoDAssets::GameInstance->Read<uint64_t>(Offset + 8);
	auto EncryptionID    = CoDAssets::GameInstance->Read<uint8_t>(Offset + 16);
	auto StringSize      = CoDAssets::GameInstance->Read<uint8_t>(Offset + 17);
	// Check 0 length
	if (StringSize == 0)
		return "";
	auto EncryptedString = (uint8_t*)CoDAssets::GameInstance->Read(Offset + 18, StringSize, BytesRead);
	// Pass to decryptor
	auto Result = DecryptString(EncryptedString, StringSize, EncryptionID, StringHash);
	// Clean up
	delete[] EncryptedString;
	// Done
	return Result;
}
void GameBlackOps4::PerformInitialSetup()
{
	// Load Caches
	AssetNameCache.LoadIndex(FileSystems::CombinePath(FileSystems::GetApplicationPath(), "package_index\\bo4_xanim.wni"));
	AssetNameCache.LoadIndex(FileSystems::CombinePath(FileSystems::GetApplicationPath(), "package_index\\bo4_ximage.wni"));
	AssetNameCache.LoadIndex(FileSystems::CombinePath(FileSystems::GetApplicationPath(), "package_index\\bo4_xmaterial.wni"));
	AssetNameCache.LoadIndex(FileSystems::CombinePath(FileSystems::GetApplicationPath(), "package_index\\bo4_xmodel.wni"));

	// Prepare to copy the oodle dll
	auto OurPath = FileSystems::CombinePath(FileSystems::GetApplicationPath(), "oo2core_6_win64.dll");

	// Copy if not exists
	if (!FileSystems::FileExists(OurPath))
		FileSystems::CopyFile(FileSystems::CombinePath(FileSystems::GetDirectoryName(CoDAssets::GameInstance->GetProcessPath()), "oo2core_6_win64.dll"), OurPath);
}